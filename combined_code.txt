// File: src/components/App.tsx
import React from 'react';
import {ChartStage} from './Canvas/ChartStage.tsx';
import {Toolbar} from './Toolbar/Toolbar.tsx';
import {SettingsToolbar} from './Toolbar/SettingsToolbar.tsx';
import '../styles/App.scss';

export const App: React.FC = () => {
    return (
        <div className={'main-app-window flex flex-col h-full w-full p-0 m-0'}>
            <div className={'settings-area'}>
                <SettingsToolbar/>
            </div>
            <div className={'lower-container flex flex-1'}>
                <div className={'toolbar-area'}>
                    <Toolbar/>
                </div>
                <div className={'chart-stage-area flex-1 h-full'}>
                    <ChartStage/>
                </div>
            </div>
        </div>
    );
};

// File: src/components/Canvas/Axes/XAxis.tsx
import React, {useEffect, useRef} from 'react';
import {useChartStore} from '../../../store/useChartStore.ts';
import {generateTimeTicks} from '../utils/generateTimeTicks.ts';
import {CanvasSizes} from "../ChartStage.tsx";

interface XAxisProps {
    canvasSizes: CanvasSizes;
    parentContainerRef?: React.RefObject<HTMLDivElement>;
}

export default function XAxis({canvasSizes, parentContainerRef = null}: XAxisProps) {

    const xAxisHeight = useChartStore(state => state.xAxisHeight);
    const visibleRange = useChartStore(state => state.visibleRange);
    const timeDetailLevel = useChartStore(state => state.timeDetailLevel);
    const timeFormat12h = useChartStore(state => state.timeFormat12h);


    const canvasRef = useRef<HTMLCanvasElement | null>(null);
    const dpr = window.devicePixelRatio || 1;

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const x_axis_canvas_width = canvas.clientWidth;
        const x_axis_canvas_height = canvas.clientHeight;

        canvas.width = x_axis_canvas_width * dpr;
        canvas.height = x_axis_canvas_height * dpr;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, x_axis_canvas_width * dpr, x_axis_canvas_height * dpr);

        // Draw X-axis line
        ctx.strokeStyle = 'black';
        ctx.fillStyle = 'black';
        ctx.font = `${12 * dpr}px Arial`;
        ctx.textBaseline = 'top';
        ctx.textAlign = 'center';

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(x_axis_canvas_width, 0);
        ctx.stroke();

        // // Generate and draw ticks
        // const ticks = generateTimeTicks(
        //     visibleRange.start,
        //     visibleRange.end,
        //     x_axis_canvas_width,
        //     timeDetailLevel,
        //     timeFormat12h
        // );
        //
        // ticks.forEach(({time, label}) => {
        //     const x = padding + ((time - visibleRange.start) / (visibleRange.end - visibleRange.start)) * x_axis_canvas_width;
        //
        //     // Draw tick mark
        //     ctx.beginPath();
        //     ctx.moveTo(x, 0);
        //     ctx.lineTo(x, 5);
        //     ctx.stroke();
        //
        //     // Draw label
        //     ctx.fillText(label, x, 12);
        // });
    }, [xAxisHeight, parentContainerRef, visibleRange, timeDetailLevel, timeFormat12h, dpr, canvasSizes]);

    return (
        <canvas
            className={`x-canvas relative block bottom-0 left-0 w-full h-full p-0 m-0 bg-white border-none pointer-events-none`}
            ref={canvasRef}
        />
    );
}


// File: src/components/Canvas/Axes/YAxis.tsx
import React, {useEffect, useRef} from 'react';
import {useChartStore} from '../../../store/useChartStore';
import {generateTimeTicks} from "../utils/generateTimeTicks.ts";
import {CanvasSizes} from "../ChartStage.tsx";

interface YAxisProps {
    parentContainerRef?: React.RefObject<HTMLDivElement>;
    canvasSizes: CanvasSizes;
}

export default function YAxis({parentContainerRef, canvasSizes}: YAxisProps) {
    const yAxisPosition = useChartStore(state => state.yAxisPosition);
    const xAxisHeight = useChartStore(state => state.xAxisHeight);
    const yAxisWidth = useChartStore(state => state.yAxisWidth);
    const minPrice = useChartStore(state => state.minPrice);
    const maxPrice = useChartStore(state => state.maxPrice);
    const numberOfYTicks = useChartStore(state => state.numberOfYTicks);

    const canvasRef = useRef<HTMLCanvasElement | null>(null);
    const dpr = window.devicePixelRatio || 1;

    function calculateTicks(): { y: number; value: number }[] {
        const y_axis_height = parentContainerRef?.current?.clientHeight || 0;
        const y_axis_width = yAxisWidth || 40; // Default width if not set
        const step = (maxPrice - minPrice) / (numberOfYTicks - 1);
        //TODO complete this function.
        return []
    }

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const y_axis_canvas_height = canvas.clientHeight;
        const y_axis_canvas_width = canvas.clientWidth; // Default width if not set

        canvas.height = y_axis_canvas_height * dpr;
        canvas.width = y_axis_canvas_width * dpr;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = 'black';
        ctx.fillStyle = 'black';
        ctx.font = `${12 * dpr}px Arial`;
        ctx.textBaseline = 'middle';
        ctx.textAlign = yAxisPosition === 'left' ? 'right' : 'left';

        ctx.beginPath();
        ctx.moveTo(y_axis_canvas_width, (y_axis_canvas_height - xAxisHeight + 1));
        ctx.lineTo(y_axis_canvas_width, 0);
        ctx.stroke();

        // const ticks = calculateTicks();
        // ticks.forEach(({y, value}) => {
        //     ctx.beginPath();
        //     ctx.moveTo(yAxisX, y);
        //     ctx.lineTo(yAxisPosition === 'left' ? yAxisX - 5 : yAxisX + 5, y);
        //     ctx.stroke();
        //
        //     const text = value.toFixed(2);
        //     const textWidth = ctx.measureText(text).width;
        //     const offsetX = yAxisPosition === 'left' ? yAxisX - 10 - textWidth : yAxisX + 10;
        //
        //     ctx.fillText(text, offsetX, y);
        // });
    }, [parentContainerRef, yAxisWidth, minPrice, maxPrice, numberOfYTicks, yAxisPosition, dpr, canvasSizes]);

    return (
        <canvas
            className={`y-canvas block relative left-${yAxisPosition === 'left' ? 0 : 'auto'} right-${yAxisPosition === 'right' ? 0 : 'auto'} top-0 bottom-0 pointer-events-none w-[100%] h-[100%]`}
            ref={canvasRef}
        />
    );
}

// File: src/components/Canvas/ChartCanvas.tsx
import React, {useRef, useEffect} from 'react';
import {Mode, useMode} from '../../contexts/ModeContext';
import {Candle} from '../../types/Candle';
import {drawGrid} from './utils/drawGrid';
import {drawCandlesticks} from './utils/drawCandlesticks';
import {drawDrawings} from './utils/drawDrawings';
import {drawOverlay} from './utils/drawOverlay';
import {useChartStore} from '../../store/useChartStore';
import {TimeRange} from "../../types/Graph.ts";

interface ChartCanvasProps {
    parentContainerRef?: React.RefObject<HTMLDivElement>;
}
export const ChartCanvas: React.FC = ({parentContainerRef}:ChartCanvasProps) => {
    const mode = useMode().mode;
    const isDrawing = useChartStore(state => state.isDrawing);
    const setIsDrawing = useChartStore(state => state.setIsDrawing);
    const startPoint = useChartStore(state => state.startPoint);
    const setStartPoint = useChartStore(state => state.setStartPoint);
    const currentPoint = useChartStore(state => state.currentPoint);
    const setCurrentPoint = useChartStore(state => state.setCurrentPoint);
    const drawings = useChartStore(state => state.drawings);
    const setDrawings = useChartStore(state => state.setDrawings);
    const selectedIndex = useChartStore(state => state.selectedIndex);
    const setSelectedIndex = useChartStore(state => state.setSelectedIndex);
    const visibleRange = useChartStore(state => state.visibleRange);
    const setVisibleRange = useChartStore(state => state.setVisibleRange);
    const candles = useChartStore(state => state.candlesToUse);
    const containerRef = useRef<HTMLDivElement | null>(null);
    const canvasRef = useRef<HTMLCanvasElement | null>(null);
    const xAxisHeight = useChartStore(state => state.xAxisHeight);

    const padding = useChartStore(state => state.padding);

    const candlesToUse = useChartStore(state => state.candlesToUse);
    const minPrice = useChartStore(state => state.minPrice);
    const maxPrice = useChartStore(state => state.maxPrice);
    const setCandlesAndVisibleRange = useChartStore(state => state.setCandlesAndVisibleRange);

    // useEffect(() => {
    //     if (!containerRef.current) return;
    //     const container = containerRef.current!;
    //     const observer = new ResizeObserver(entries => {
    //         for (const entry of entries) {
    //             setCanvasWidth(entry.contentRect.width);
    //             setCanvasHeight(entry.contentRect.height);
    //         }
    //     });
    //     observer.observe(container);
    //     return () => {
    //         observer.disconnect();
    //     };
    // }, []);

    const now = Date.now();
    const oneYearAgo = now - 365 * 24 * 60 * 60 * 1000;
    const defaultVisibleRange: TimeRange = {
        start: oneYearAgo,
        end: now,
    };

    // Initialize visibleRange in store if not set and initialVisibleRange is provided
    useEffect(() => {
        if (!visibleRange || visibleRange.start === 0 || visibleRange.end === 0) {
            setVisibleRange(defaultVisibleRange);
        }
    }, [candles, visibleRange, setVisibleRange]);

    // useEffect for setting candles and visible range in store
    useEffect(() => {
        setCandlesAndVisibleRange(candles, visibleRange || {start: 0, end: Date.now()});
    }, [candles, visibleRange, setCandlesAndVisibleRange]);

    const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
        if (!canvasRef.current) return;
        const rect = canvasRef.current!.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        if (mode === Mode.select) {
            for (let i = 0; i < drawings.length; i++) {
                const d = drawings[i];
                let shape = null;
                if (d.mode === Mode.drawLine) {
                    // @ts-ignore
                    shape = new LineShape(d.args.startX, d.args.startY, d.args.endX, d.args.endY);
                } else if (d.mode === Mode.drawRectangle) {
                    // @ts-ignore
                    shape = new RectangleShape(d.args.x, d.args.y, d.args.width, d.args.height);
                } else if (d.mode === Mode.drawCircle) {
                    // @ts-ignore
                    shape = new CircleShape(d.args.centerX, d.args.centerY, d.args.radius);
                }
                if (shape && shape.isHit(x, y)) {
                    setSelectedIndex(i);
                    return;
                }
            }
            setSelectedIndex(null);
            return;
        }

        if (mode !== Mode.none) {
            setStartPoint({x, y});
            setIsDrawing(true);
        }
    };

    const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
        if (!isDrawing || !startPoint || mode === Mode.none) return;
        if (!canvasRef.current) return;

        const rect = canvasRef.current!.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        setCurrentPoint({x, y});
    };

    const handleMouseUp = (e: React.MouseEvent<HTMLCanvasElement>) => {
        if (!isDrawing || !startPoint || mode === Mode.none) return;
        if (!canvasRef.current) return;

        const rect = canvasRef.current!.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        setDrawings(prev => {
            const newDrawing = {
                [Mode.drawLine]: () => ({
                    mode: Mode.drawLine,
                    args: {
                        startX: startPoint.x,
                        startY: startPoint.y,
                        endX: x,
                        endY: y,
                    },
                }),
                [Mode.drawRectangle]: () => ({
                    mode: Mode.drawRectangle,
                    args: {
                        x: startPoint.x,
                        y: startPoint.y,
                        width: x - startPoint.x,
                        height: y - startPoint.y,
                    },
                }),
                [Mode.drawCircle]: () => {
                    const dx = x - startPoint.x;
                    const dy = y - startPoint.y;
                    const radius = Math.sqrt(dx * dx + dy * dy);
                    return {
                        mode: Mode.drawCircle,
                        args: {
                            centerX: startPoint.x,
                            centerY: startPoint.y,
                            radius,
                        },
                    };
                }
            };
            return newDrawing[mode] ? [...prev, newDrawing[mode]()] : prev;
        });

        setIsDrawing(false);
        setStartPoint(null);
        setCurrentPoint(null);
    };

    function formatUnixTime(unixTime: number): string {
        const date = new Date(unixTime);
        const options: Intl.DateTimeFormatOptions = {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
        };
        return new Intl.DateTimeFormat('he-IL', options).format(date);
    }

    useEffect(() => {
        // const canvas = canvasRef.current;
        // if (!canvas) return;
        // if (canvasWidth === 0 || canvasHeight === 0) return;
        // const ctx = canvas.getContext('2d');
        // if (!ctx) return;
        //
        // const dpr = window.devicePixelRatio || 1;
        // canvas.style.width = `${canvasWidth}px`;
        // canvas.style.height = `${canvasHeight}px`;
        //
        // ctx.setTransform(1, 0, 0, 1, 0, 0);
        // ctx.scale(dpr, dpr);
        //
        // ctx.clearRect(0, 0, canvas.width, canvasHeight);

        // drawGrid(ctx);
        // drawCandlesticks(ctx, candlesToUse, visibleRange, padding, minPrice, maxPrice);
        // drawDrawings(ctx, drawings, selectedIndex);
        // drawOverlay(ctx, mode, isDrawing, startPoint, currentPoint);

    }, [
        candlesToUse,
        visibleRange,
        drawings,
        selectedIndex,
        mode,
        isDrawing,
        startPoint,
        currentPoint,
        padding,
        minPrice,
        maxPrice,
    ]);

    return (
        <div className="canvas-container relative" style={{width: '100%', height: `calc(100% - ${xAxisHeight}px)`}}>

            <canvas
                className={'canvas flex relative w-full h-full p-0 m-0 bg-white border-none pointer-events-auto'}
                ref={canvasRef}
                onMouseDown={handleMouseDown}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
            />
        </div>
    );
};

// File: src/components/Canvas/ChartStage.tsx
import React, {useEffect, useRef, useState} from 'react';
import {ChartCanvas} from './ChartCanvas';
import {useChartStore} from "../../store/useChartStore.ts";
import XAxis from "./Axes/XAxis.tsx";
import YAxis from "./Axes/YAxis.tsx";
import '../../styles/Canvas/ChartStage.scss';

export interface CanvasSizes {
    width: number;
    height: number;
}

// Logger utility
class DebugLogger {
    private logs: string[] = [];

    log(message: string, data?: any) {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = `[${timestamp}] ${message}${data ? '\n' + JSON.stringify(data, null, 2) : ''}`;
        this.logs.push(logEntry);
        console.log(message, data);
    }

    getLogs() {
        return this.logs.join('\n\n');
    }

    downloadLogs() {
        const logContent = this.getLogs();
        const blob = new Blob([logContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `resize-debug-${new Date().toISOString().slice(0, 19)}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    clear() {
        this.logs = [];
    }
}

const logger = new DebugLogger();

export const ChartStage: React.FC = () => {
    const yAxisPosition = useChartStore(state => state.yAxisPosition);
    const margin = useChartStore(state => state.margin);
    const xAxisHeight = useChartStore(state => state.xAxisHeight);
    const yAxisWidth = useChartStore(state => state.yAxisWidth);
    const [canvasSizes, setCanvasSizes] = useState<CanvasSizes>({width: 0, height: 0});
    const [logCount, setLogCount] = useState(0);
    const containerRef = useRef<HTMLDivElement | null>(null);

    useEffect(() => {
        if (!containerRef.current) return;

        const element = containerRef.current!;

        // Initial size logging
        const initialRect = element.getBoundingClientRect();
        logger.log('üî∑ Initial container size:', {
            width: initialRect.width,
            height: initialRect.height,
            clientWidth: element.clientWidth,
            clientHeight: element.clientHeight,
            offsetWidth: element.offsetWidth,
            offsetHeight: element.offsetHeight
        });

        // Log computed styles that might affect sizing
        const computedStyle = window.getComputedStyle(element);
        logger.log('üî∑ Container computed styles:', {
            width: computedStyle.width,
            height: computedStyle.height,
            minWidth: computedStyle.minWidth,
            minHeight: computedStyle.minHeight,
            maxWidth: computedStyle.maxWidth,
            maxHeight: computedStyle.maxHeight,
            boxSizing: computedStyle.boxSizing,
            display: computedStyle.display,
            flexGrow: computedStyle.flexGrow,
            flexShrink: computedStyle.flexShrink,
            flexBasis: computedStyle.flexBasis,
            overflow: computedStyle.overflow
        });

        // Check parent chain
        let parent = element.parentElement;
        let level = 1;
        while (parent && level <= 3) {
            const parentRect = parent.getBoundingClientRect();
            const parentStyle = window.getComputedStyle(parent);
            logger.log(`üî∑ Parent ${level} (${parent.className}):`, {
                size: { width: parentRect.width, height: parentRect.height },
                minWidth: parentStyle.minWidth,
                maxWidth: parentStyle.maxWidth,
                display: parentStyle.display,
                overflow: parentStyle.overflow,
                flexGrow: parentStyle.flexGrow,
                flexShrink: parentStyle.flexShrink
            });
            parent = parent.parentElement;
            level++;
        }

        const resizeObserver = new ResizeObserver(entries => {
            logger.log('üü¢ ResizeObserver triggered!');
            setLogCount(prev => prev + 1);

            for (let entry of entries) {
                const { width, height } = entry.contentRect;
                const { target } = entry;

                logger.log('üü¢ ResizeObserver data:', {
                    contentRect: { width, height },
                    borderBoxSize: entry.borderBoxSize?.[0],
                    contentBoxSize: entry.contentBoxSize?.[0],
                    targetClass: (target as HTMLElement).className,
                    currentCanvasSizes: canvasSizes
                });

                // Also log current element measurements
                const currentRect = element.getBoundingClientRect();
                logger.log('üü¢ Current element measurements:', {
                    getBoundingClientRect: { width: currentRect.width, height: currentRect.height },
                    clientSize: { width: element.clientWidth, height: element.clientHeight },
                    offsetSize: { width: element.offsetWidth, height: element.offsetHeight }
                });

                setCanvasSizes(prev => {
                    if (prev.width !== width || prev.height !== height) {
                        logger.log('üîÑ Updating canvas sizes:', {
                            from: prev,
                            to: { width, height },
                            change: {
                                width: width - prev.width,
                                height: height - prev.height
                            }
                        });
                        return { width, height };
                    }
                    logger.log('üö´ No size change, keeping previous:', prev);
                    return prev;
                });
            }
        });

        // Add window resize listener for comparison
        const handleWindowResize = () => {
            const windowSize = { width: window.innerWidth, height: window.innerHeight };
            const elementRect = element.getBoundingClientRect();
            logger.log('üåç Window resize:', {
                window: windowSize,
                element: { width: elementRect.width, height: elementRect.height }
            });
            setLogCount(prev => prev + 1);
        };

        window.addEventListener('resize', handleWindowResize);
        resizeObserver.observe(element);

        logger.log('üî∑ ResizeObserver attached to element:', { className: element.className });

        return () => {
            logger.log('üî¥ Cleaning up ResizeObserver');
            window.removeEventListener('resize', handleWindowResize);
            resizeObserver.disconnect();
        };
    }, []);

    // Log every render
    logger.log('üîÑ ChartStage render:', {
        canvasSizes,
        containerRefCurrent: !!containerRef.current
    });

    return (
        <div
            ref={containerRef}
            style={{margin: `${margin}px`}}
            className="chart-stage-container flex w-full h-full">

            {/* Debug controls */}
            <div style={{
                position: 'fixed',
                top: '10px',
                right: '10px',
                background: 'white',
                border: '1px solid #ccc',
                padding: '10px',
                borderRadius: '5px',
                zIndex: 2000,
                boxShadow: '0 2px 10px rgba(0,0,0,0.1)'
            }}>
                <div style={{ fontSize: '12px', marginBottom: '5px' }}>
                    Debug Logger ({logCount} events)
                </div>
                <button
                    onClick={() => logger.downloadLogs()}
                    style={{
                        padding: '5px 10px',
                        marginRight: '5px',
                        fontSize: '12px',
                        cursor: 'pointer'
                    }}
                >
                    üíæ Download Logs
                </button>
                <button
                    onClick={() => {
                        logger.clear();
                        setLogCount(0);
                    }}
                    style={{
                        padding: '5px 10px',
                        fontSize: '12px',
                        cursor: 'pointer'
                    }}
                >
                    üóëÔ∏è Clear
                </button>
            </div>

            {/* Size indicator */}
            <div style={{
                position: 'absolute',
                top: 0,
                left: 0,
                background: 'rgba(255,0,0,0.1)',
                padding: '4px',
                fontSize: '12px',
                zIndex: 1000,
                pointerEvents: 'none'
            }}>
                Container: {Math.round(canvasSizes.width)}√ó{Math.round(canvasSizes.height)}
            </div>

            {yAxisPosition === 'left' && (
                <div className="right-y-axis-container relative flex h-full" style={{width: `${yAxisWidth}px`}}>
                    <YAxis containerRef={containerRef} canvasSizes={canvasSizes}/>
                </div>
            )}

            <div className="canvas-axis-container relative flex h-full" style={{
                width: `${canvasSizes.width - (yAxisWidth + 40)}px`,
                marginLeft: `${yAxisPosition === 'left' ? 0 : 40}px`,
                marginRight: `${yAxisPosition === 'right' ? 0 : 40}px`
            }}>
                <div className={`canvas-container relative`}>
                    <ChartCanvas parentContainerRef={containerRef}/>
                </div>
                <div className="x-axis-container absolute bottom-0 left-0 w-full" style={{height: `${xAxisHeight}px`}}>
                    <XAxis containerRef={containerRef} canvasSizes={canvasSizes}/>
                </div>
            </div>

            {yAxisPosition === 'right' && (
                <div className="left-y-axis-container relative flex h-full" style={{width: `${yAxisWidth}px`}}>
                    <YAxis containerRef={containerRef} canvasSizes={canvasSizes}/>
                </div>
            )}
        </div>
    );
};

// File: src/components/Canvas/utils/drawCandlesticks.ts
import { Candle } from '../../../types/Candle';

export function drawCandlesticks(
  ctx: CanvasRenderingContext2D,
  candles: Candle[],
  visibleRange: { start: number; end: number },
  padding: number,
  minPrice: number,
  maxPrice: number,
  width: number,
  height: number
): void {
  const drawableWidth = width - 2 * padding;
  const drawableHeight = height - 2 * padding;

  const candleCount = visibleRange.end - visibleRange.start;
  if (candleCount <= 0) return;

  const candleSpacing = drawableWidth / candleCount;
  const candleWidth = candleSpacing * 0.6;

  const priceRange = maxPrice - minPrice;

  // ◊§◊ï◊†◊ß◊¶◊ô◊î ◊ú◊î◊û◊®◊™ ◊û◊ó◊ô◊® ◊ú◊û◊ô◊ß◊ï◊ù Y ◊ë◊ß◊†◊ë◊°
  const priceToY = (price: number) => {
    return padding + drawableHeight * (1 - (price - minPrice) / priceRange);
  };

  const visibleCandles = candles.slice(visibleRange.start, visibleRange.end);

  visibleCandles.forEach((candle, i) => {
    const x = padding + i * candleSpacing;
    const highY = priceToY(candle.h);
    const lowY = priceToY(candle.l);
    const openY = priceToY(candle.o);
    const closeY = priceToY(candle.c);

    const isUp = candle.c >= candle.o;

    ctx.strokeStyle = isUp ? 'green' : 'red';
    ctx.fillStyle = isUp ? 'green' : 'red';
    ctx.lineWidth = 1;

    // ◊¶◊ô◊ï◊® ◊î-wick (◊î◊ß◊ï ◊î◊¢◊ú◊ô◊ï◊ü ◊ï◊î◊™◊ó◊™◊ï◊ü)
    ctx.beginPath();
    ctx.moveTo(x + candleWidth / 2, highY);
    ctx.lineTo(x + candleWidth / 2, lowY);
    ctx.stroke();

    // ◊¶◊ô◊ï◊® ◊í◊ï◊£ ◊î◊†◊®
    const bodyY = Math.min(openY, closeY);
    const bodyHeight = Math.max(1, Math.abs(openY - closeY)); // ◊ú◊§◊ó◊ï◊™ 1 ◊§◊ô◊ß◊°◊ú ◊í◊ï◊ë◊î
    ctx.fillRect(x, bodyY, candleWidth, bodyHeight);
  });
}


// File: src/components/Canvas/utils/drawDrawings.ts


import { Drawing } from '../../Drawing/types';
import { LineShape } from '../../Drawing/LineShape';
import { RectangleShape } from '../../Drawing/RectangleShape';
import { CircleShape } from '../../Drawing/CircleShape';
import { TriangleShape } from '../../Drawing/TriangleShape';
import { AngleShape } from '../../Drawing/AngleShape';
import { Polyline } from '../../Drawing/Polyline';
import { ArrowShape } from '../../Drawing/ArrowShape';
import { CustomSymbolShape } from '../../Drawing/CustomSymbolShape';
import { Mode } from '../../../contexts/ModeContext';

export function drawDrawings(
  ctx: CanvasRenderingContext2D,
  drawings: Drawing[],
  selectedIndex: number | null,
  width: number,
  height: number
): void {
  drawings.forEach((d, index) => {
    ctx.beginPath();
    let shape = null;
    switch (d.mode) {
      case Mode.drawLine:
        shape = new LineShape(
          d.args.startX,
          d.args.startY,
          d.args.endX,
          d.args.endY
        );
        break;
      case Mode.drawRectangle:
        shape = new RectangleShape(
          d.args.x,
          d.args.y,
          d.args.width,
          d.args.height
        );
        break;
      case Mode.drawCircle:
        shape = new CircleShape(
          d.args.centerX,
          d.args.centerY,
          d.args.radius
        );
        break;
      case Mode.drawTriangle:
        shape = new TriangleShape(
          d.args.x1,
          d.args.y1,
          d.args.x2,
          d.args.y2,
          d.args.x3,
          d.args.y3
        );
        break;
      case Mode.drawAngle:
        shape = new AngleShape(
          d.args.x0,
          d.args.y0,
          d.args.x1,
          d.args.y1,
          d.args.x2,
          d.args.y2
        );
        break;
      case Mode.drawPolyline:
        shape = new Polyline(d.args.points);
        break;
      case Mode.drawArrow:
        shape = new ArrowShape(
          d.args.fromX,
          d.args.fromY,
          d.args.toX,
          d.args.toY
        );
        break;
      case Mode.drawCustomSymbol:
        shape = new CustomSymbolShape(
          d.args.x,
          d.args.y,
          d.args.symbol,
          d.args.size,
          d.args.color
        );
        break;
      default:
        break;
    }

    if (shape) {
      if (selectedIndex === index) {
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
      } else {
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
      }
      shape.draw(ctx);
      ctx.stroke();
    }
  });
}

// File: src/components/Canvas/utils/drawGrid.ts
export function drawGrid(ctx: CanvasRenderingContext2D, width: number, height: number) {
  const stepX = 50; // ◊®◊ô◊ï◊ï◊ó ◊ê◊ï◊§◊ß◊ô ◊ë◊ô◊ü ◊ß◊ï◊ï◊ô◊ù, ◊†◊ô◊™◊ü ◊ú◊©◊†◊ï◊™
  const stepY = 50; // ◊®◊ô◊ï◊ï◊ó ◊ê◊†◊õ◊ô ◊ë◊ô◊ü ◊ß◊ï◊ï◊ô◊ù, ◊†◊ô◊™◊ü ◊ú◊©◊†◊ï◊™
  const strokeStyle = '#ccc'; // ◊¶◊ë◊¢ ◊î◊ß◊ï◊ï◊ô◊ù, ◊†◊ô◊™◊ü ◊ú◊©◊†◊ï◊™

  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = 1;

  // ◊ß◊¶◊ï◊ï◊™ ◊î◊í◊®◊ô◊ì
  const xStart = 0;
  const xEnd = width;
  const yStart = 0;
  const yEnd = height;

  // ◊ß◊ï◊ï◊ô◊ù ◊ê◊†◊õ◊ô◊ô◊ù
  for (let x = xStart; x <= xEnd; x += stepX) {
    ctx.beginPath();
    ctx.moveTo(x, yStart);
    ctx.lineTo(x, yEnd);
    ctx.stroke();
  }

  // ◊ß◊ï◊ï◊ô◊ù ◊ê◊ï◊§◊ß◊ô◊ô◊ù
  for (let y = yStart; y <= yEnd; y += stepY) {
    ctx.beginPath();
    ctx.moveTo(xStart, y);
    ctx.lineTo(xEnd, y);
    ctx.stroke();
  }
}


// File: src/components/Canvas/utils/drawOverlay.ts
import { Mode } from '../../../contexts/ModeContext';

export function drawOverlay(
  ctx: CanvasRenderingContext2D,
  mode: Mode,
  isDrawing: boolean,
  startPoint: { x: number; y: number } | null,
  currentPoint: { x: number; y: number } | null,
  width: number,
  height: number
) {
  if (!isDrawing || !startPoint || !currentPoint) return;

  ctx.strokeStyle = 'blue';
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 5]); // ◊ß◊ï ◊û◊†◊ï◊ß◊ì

  ctx.beginPath();
  switch (mode) {
    case Mode.drawLine:
      ctx.moveTo(startPoint.x, startPoint.y);
      ctx.lineTo(currentPoint.x, currentPoint.y);
      break;

    case Mode.drawRectangle:
      ctx.rect(
        Math.min(startPoint.x, currentPoint.x),
        Math.min(startPoint.y, currentPoint.y),
        Math.abs(currentPoint.x - startPoint.x),
        Math.abs(currentPoint.y - startPoint.y)
      );
      break;

    case Mode.drawCircle:
      const dx = currentPoint.x - startPoint.x;
      const dy = currentPoint.y - startPoint.y;
      const radius = Math.sqrt(dx * dx + dy * dy);
      ctx.arc(startPoint.x, startPoint.y, radius, 0, Math.PI * 2);
      break;

    default:
      ctx.setLineDash([]);
      return;
  }

  ctx.stroke();
  ctx.setLineDash([]);
}

// File: src/components/Canvas/utils/generateTimeTicks.ts
import { Tick } from "../../../types/Graph.ts";

type TimeDetailLevel = 'auto' | 'low' | 'medium' | 'high';

export function generateTimeTicks(
    startTime: number,
    endTime: number,
    canvasWidth: number,
    timeDetailLevel: TimeDetailLevel,
    timeFormat12h: boolean,
    minPixelPerTick = 60,
): Tick[] {
    const ticks: Tick[] = [];
    const rangeMs = endTime - startTime;

    // Calculate time span in days
    const timeSpanDays = rangeMs / (24 * 60 * 60 * 1000);

    // Determine appropriate tick interval based on time span
    let interval: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second';
    let intervalStep = 1;

    if (timeSpanDays > 365 * 2) {
        interval = 'year';
        intervalStep = Math.ceil(timeSpanDays / 365 / 10); // Show approximately 10 years
    } else if (timeSpanDays > 60) {
        interval = 'month';
        intervalStep = Math.ceil(timeSpanDays / 30 / 12); // Show approximately 12 months
    } else if (timeSpanDays > 10) {
        interval = 'day';
        intervalStep = Math.ceil(timeSpanDays / 10); // Show approximately 10 days
    } else if (timeSpanDays > 1) {
        interval = 'hour';
        intervalStep = Math.ceil(timeSpanDays * 24 / 12); // Show approximately 12 hours
    } else if (timeSpanDays > 0.04) { // ~1 hour
        interval = 'minute';
        intervalStep = Math.ceil(timeSpanDays * 24 * 60 / 15); // Show approximately every 15 minutes
    } else {
        interval = 'second';
        intervalStep = Math.ceil(timeSpanDays * 24 * 60 * 60 / 15); // Show approximately every 15 seconds
    }

    // Override with user-selected detail level if not auto
    if (timeDetailLevel !== 'auto') {
        switch (timeDetailLevel) {
            case 'low':
                if (interval === 'year') intervalStep = Math.max(intervalStep, 2);
                else if (interval === 'month') interval = 'year';
                else if (interval === 'day') interval = 'month';
                else if (interval === 'hour') interval = 'day';
                else if (interval === 'minute') interval = 'hour';
                else interval = 'minute';
                break;
            case 'medium':
                // Keep default interval but maybe adjust step
                break;
            case 'high':
                if (interval === 'year') interval = 'month';
                else if (interval === 'month') interval = 'day';
                else if (interval === 'day') interval = 'hour';
                else if (interval === 'hour') interval = 'minute';
                else if (interval === 'minute') interval = 'second';
                intervalStep = 1;
                break;
        }
    }

    // Calculate max ticks based on canvas width
    const maxTicks = Math.floor(canvasWidth / minPixelPerTick);

    // Generate ticks based on interval
    const startDate = new Date(startTime);
    const endDate = new Date(endTime);

    // Function to get next tick date based on interval
    function getNextTickDate(date: Date): Date {
        const newDate = new Date(date);
        switch (interval) {
            case 'year':
                newDate.setFullYear(newDate.getFullYear() + intervalStep);
                break;
            case 'month':
                newDate.setMonth(newDate.getMonth() + intervalStep);
                break;
            case 'day':
                newDate.setDate(newDate.getDate() + intervalStep);
                break;
            case 'hour':
                newDate.setHours(newDate.getHours() + intervalStep);
                break;
            case 'minute':
                newDate.setMinutes(newDate.getMinutes() + intervalStep);
                break;
            case 'second':
                newDate.setSeconds(newDate.getSeconds() + intervalStep);
                break;
        }
        return newDate;
    }

    // Function to format date based on interval
    function formatTickLabel(date: Date): string {
        switch (interval) {
            case 'year':
                return date.getFullYear().toString();
            case 'month':
                return date.toLocaleString('default', { month: 'short', year: 'numeric' });
            case 'day':
                return date.toLocaleString('default', { day: '2-digit', month: 'short' });
            case 'hour':
                return date.toLocaleString('default', { hour12: timeFormat12h, hour: '2-digit', minute: '2-digit' });
            case 'minute':
                return date.toLocaleString('default', { hour12: timeFormat12h, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            case 'second':
                return date.toLocaleString('default', { hour12: timeFormat12h, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }
    }
    
    // Find first tick (align to interval boundary)
    let currentDate = new Date(startDate);
    switch (interval) {
        case 'year':
            currentDate = new Date(currentDate.getFullYear(), 0, 1);
            break;
        case 'month':
            currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
            break;
        case 'day':
            currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
            break;
        case 'hour':
            currentDate = new Date(
                currentDate.getFullYear(), 
                currentDate.getMonth(), 
                currentDate.getDate(), 
                currentDate.getHours()
            );
            break;
        case 'minute':
            currentDate = new Date(
                currentDate.getFullYear(), 
                currentDate.getMonth(), 
                currentDate.getDate(), 
                currentDate.getHours(),
                Math.floor(currentDate.getMinutes() / intervalStep) * intervalStep
            );
            break;
        case 'second':
            currentDate = new Date(
                currentDate.getFullYear(), 
                currentDate.getMonth(), 
                currentDate.getDate(), 
                currentDate.getHours(),
                currentDate.getMinutes(),
                Math.floor(currentDate.getSeconds() / intervalStep) * intervalStep
            );
            break;
    }
    
    // If first tick is before start time, move to next tick
    if (currentDate.getTime() < startTime) {
        currentDate = getNextTickDate(currentDate);
    }
    
    // Generate ticks until we reach end time
    while (currentDate.getTime() <= endTime) {
        const tickTime = currentDate.getTime();
        const label = formatTickLabel(currentDate);
        
        ticks.push({ time: tickTime, label });
        currentDate = getNextTickDate(currentDate);
        
        // Safety check to prevent infinite loops
        if (ticks.length > 100) break;
    }
    
    // Ensure we don't have too many ticks for the available width
    if (ticks.length > maxTicks) {
        // Sample ticks evenly
        const step = Math.ceil(ticks.length / maxTicks);
        return ticks.filter((_, i) => i % step === 0);
    }
    
    return ticks;
}


// File: src/components/Canvas/utils/generateXTicks.ts
// ================================
// TYPE DEFINITIONS & INTERFACES
// ================================

/**
 * @typedef {Object} Candle
 * @property {number} t - Timestamp (Unix timestamp in seconds)
 * @property {number} o - Open price
 * @property {number} c - Close price
 * @property {number} h - High price
 * @property {number} l - Low price
 */

/**
 * @typedef {Object} CanvasDimensions
 * @property {number} width - Canvas width in pixels
 * @property {number} height - Canvas height in pixels
 */

/**
 * @typedef {Object} TickOptions
 * @property {'standard'|'ui-friendly'} labelType - Label formatting type
 * @property {'dd/mm/yy'|'mm/dd/yy'|'yyyy-mm-dd'} [dateFormat] - Date format for standard labels
 * @property {'hh:mm'|'hh:mm:ss'|'HH:MM'} [timeFormat] - Time format for standard labels
 * @property {string} [locale] - Locale for internationalization
 */

/**
 * @typedef {Object} Tick
 * @property {string} label - Display label for the tick
 * @property {number} x - X position on canvas in pixels
 * @property {number} timestamp - Unix timestamp of the tick
 * @property {'minute'|'hour'|'day'|'week'|'month'|'year'} [type] - Type for UI-friendly labels
 */

/**
 * @typedef {Object} TimeRange
 * @property {number} start - Start timestamp (Unix seconds)
 * @property {number} end - End timestamp (Unix seconds)
 */

/**
 * @typedef {Object} ParsedTimeRange
 * @property {number} value - Numeric value (e.g., 1, 5, 30)
 * @property {string} unit - Time unit (minutes, hours, days, etc.)
 * @property {number} seconds - Total seconds in the range
 */

// ================================
// ENUMS & CONSTANTS
// ================================

const TIME_RANGE_PATTERNS = {
    // Minutes
    '1m': { value: 1, unit: 'minutes', seconds: 60 },
    '2m': { value: 2, unit: 'minutes', seconds: 120 },
    '5m': { value: 5, unit: 'minutes', seconds: 300 },
    '15m': { value: 15, unit: 'minutes', seconds: 900 },
    '30m': { value: 30, unit: 'minutes', seconds: 1800 },

    // Hours
    '1h': { value: 1, unit: 'hours', seconds: 3600 },
    '2h': { value: 2, unit: 'hours', seconds: 7200 },
    '4h': { value: 4, unit: 'hours', seconds: 14400 },
    '6h': { value: 6, unit: 'hours', seconds: 21600 },
    '12h': { value: 12, unit: 'hours', seconds: 43200 },

    // Days
    '1d': { value: 1, unit: 'days', seconds: 86400 },
    '3d': { value: 3, unit: 'days', seconds: 259200 },
    '5d': { value: 5, unit: 'days', seconds: 432000 },

    // Weeks
    '1w': { value: 1, unit: 'weeks', seconds: 604800 },
    '2w': { value: 2, unit: 'weeks', seconds: 1209600 },

    // Months (approximate)
    '1M': { value: 1, unit: 'months', seconds: 2629746 },
    '3M': { value: 3, unit: 'months', seconds: 7889238 },
    '6M': { value: 6, unit: 'months', seconds: 15778476 },

    // Years
    '1y': { value: 1, unit: 'years', seconds: 31556952 },
    '2y': { value: 2, unit: 'years', seconds: 63113904 },
    '5y': { value: 5, unit: 'years', seconds: 157784760 }
};

const TICK_INTERVALS = {
    MINUTE_1: 60,
    MINUTE_2: 120,
    MINUTE_5: 300,
    MINUTE_10: 600,
    MINUTE_15: 900,
    MINUTE_30: 1800,
    HOUR_1: 3600,
    HOUR_2: 7200,
    HOUR_4: 14400,
    HOUR_6: 21600,
    HOUR_12: 43200,
    DAY_1: 86400,
    DAY_5: 432000,
    WEEK_1: 604800,
    WEEK_2: 1209600,
    MONTH_1: 2629746
};

// Pre-sorted for binary search optimization
const TICK_INTERVAL_HIERARCHY = [
    TICK_INTERVALS.MINUTE_1,
    TICK_INTERVALS.MINUTE_2,
    TICK_INTERVALS.MINUTE_5,
    TICK_INTERVALS.MINUTE_10,
    TICK_INTERVALS.MINUTE_15,
    TICK_INTERVALS.MINUTE_30,
    TICK_INTERVALS.HOUR_1,
    TICK_INTERVALS.HOUR_2,
    TICK_INTERVALS.HOUR_4,
    TICK_INTERVALS.HOUR_6,
    TICK_INTERVALS.HOUR_12,
    TICK_INTERVALS.DAY_1,
    TICK_INTERVALS.DAY_5,
    TICK_INTERVALS.WEEK_1,
    TICK_INTERVALS.WEEK_2,
    TICK_INTERVALS.MONTH_1
];

export enum LABEL_TYPE {
    STANDARD,
    UI_FRIENDLY
}

const UI_LABEL_TYPES = {
    MINUTE: 'minute',
    HOUR: 'hour',
    DAY: 'day',
    WEEK: 'week',
    MONTH: 'month',
    YEAR: 'year'
};

interface TicksOptions {
    labelType?: LABEL_TYPE;
    dateFormat?: 'dd/mm/yy' | 'mm/dd/yy' | 'yyyy-mm-dd';
    timeFormat?: 'hh:mm' | 'hh:mm:ss' | 'HH:MM';
    locale?: string; // e.g., 'en-US', 'he-IL'
}

const DEFAULT_OPTIONS: TicksOptions = {
    labelType: LABEL_TYPE.STANDARD,
    dateFormat: 'dd/mm/yy',
    timeFormat: 'hh:mm',
    locale: 'en-US'
};

// ================================
// FORMATTER CACHE
// ================================

const formatterCache = new Map();

function getFormatter(locale, formatOptions) {
    const key = `${locale}_${JSON.stringify(formatOptions)}`;
    if (!formatterCache.has(key)) {
        formatterCache.set(key, new Intl.DateTimeFormat(locale, formatOptions));
    }
    return formatterCache.get(key);
}

// ================================
// MAIN FUNCTION - OPTIMIZED
// ================================

/**
 * Generates X-axis ticks for time-based charts with intelligent spacing and labeling
 *
 * @param {string} timeRange - Time range specification (e.g., '1d', '1w', '1M', '1y')
 * @param {number|'auto'} minMaxTicks - Min/max ticks requirement or 'auto' for automatic
 * @param {Candle[]} candlesData - Array of candle objects with t,o,c,h,l properties
 * @param {CanvasDimensions} canvasDimensions - Canvas width and height in pixels
 * @param {number} textSizePixels - Text size in pixels for label width calculations
 * @param {TickOptions} [options] - Optional formatting and localization options
 * @returns {Tick[]} Array of tick objects with label, x position, and timestamp
 */
export function generateXTicks(timeRange, minMaxTicks, candlesData, canvasDimensions, textSizePixels, options:TicksOptions = {}) {

    // Performance profiling start
    const startTime = performance.now();

    // ================================
    // 1. INPUT VALIDATION
    // ================================

    if (!timeRange || typeof timeRange !== 'string') {
        throw new Error('Invalid timeRange: must be a string like "1d", "1w", etc.');
    }

    if (!TIME_RANGE_PATTERNS[timeRange]) {
        throw new Error(`Unsupported timeRange: ${timeRange}`);
    }

    if (!Array.isArray(candlesData) || candlesData.length === 0) {
        return [];
    }

    if (!canvasDimensions || canvasDimensions.width <= 0 || canvasDimensions.height <= 0) {
        throw new Error('Invalid canvasDimensions');
    }

    if (textSizePixels <= 0) {
        textSizePixels = 12; // default
    }

    // Merge with default options
    options = { ...DEFAULT_OPTIONS, ...options };

    // ================================
    // 2. DATA VALIDATION & PREPROCESSING
    // ================================

    // Filter out invalid candles
    const validCandles = candlesData.filter(candle =>
        candle != null &&
        typeof candle.t === 'number' &&
        typeof candle.o === 'number' &&
        typeof candle.c === 'number' &&
        typeof candle.h === 'number' &&
        typeof candle.l === 'number' &&
        candle.t > 0
    );

    if (validCandles.length === 0) {
        return [];
    }

    // Sort candles by timestamp ascending
    validCandles.sort((a, b) => a.t - b.t);

    // ================================
    // 3. CALCULATE ACTUAL TIME RANGE
    // ================================

    const parsedRange = TIME_RANGE_PATTERNS[timeRange];
    const latestCandleTime = validCandles[validCandles.length - 1].t;
    const calculatedTimeRange = {
        end: latestCandleTime,
        start: latestCandleTime - parsedRange.seconds
    };

    // Filter candles within the calculated time range
    const candlesInRange = validCandles.filter(candle =>
        candle.t >= calculatedTimeRange.start && candle.t <= calculatedTimeRange.end
    );

    if (candlesInRange.length === 0) {
        return [];
    }

    // Update time range to actual data boundaries if needed
    const actualTimeRange = {
        start: Math.max(calculatedTimeRange.start, candlesInRange[0].t),
        end: Math.min(calculatedTimeRange.end, candlesInRange[candlesInRange.length - 1].t)
    };

    // ================================
    // 4. PERFORMANCE OPTIMIZATIONS - PRECOMPUTE VALUES
    // ================================

    const timeSpanSeconds = actualTimeRange.end - actualTimeRange.start;

    // OPTIMIZATION 2: Cache estimated label width calculation
    const estimatedLabelWidth = calculateEstimatedLabelWidth(textSizePixels, options.labelType, parsedRange);
    const minSpacingPixels = estimatedLabelWidth + 20; // padding between labels
    const maxPossibleTicks = Math.floor(canvasDimensions.width / minSpacingPixels);

    // OPTIMIZATION 3: Precompute pixel-per-second ratio
    const pixelPerSecond = canvasDimensions.width / timeSpanSeconds;

    // ================================
    // 5. DETERMINE OPTIMAL TICK INTERVAL
    // ================================

    // Determine target number of ticks
    const targetTicks = determineTargetTickCount(minMaxTicks, maxPossibleTicks, parsedRange);

    // OPTIMIZATION 5: Use binary search for interval selection
    const optimalTickInterval = selectOptimalTickIntervalBinary(timeSpanSeconds, targetTicks, TICK_INTERVAL_HIERARCHY);

    // ================================
    // 6. GENERATE TICK POSITIONS - OPTIMIZED
    // ================================

    // Align start time to interval boundaries for clean ticks
    const alignedStartTime = alignTimeToInterval(actualTimeRange.start, optimalTickInterval);

    const rawTicks = [];
    let currentTime = alignedStartTime;
    let previousLabelInfo = null;

    while (currentTime <= actualTimeRange.end && rawTicks.length < maxPossibleTicks) {

        if (currentTime >= actualTimeRange.start) {

            // OPTIMIZATION 3: Use precomputed pixelPerSecond
            const xPosition = Math.floor((currentTime - actualTimeRange.start) * pixelPerSecond);

            // Store minimal tick info first (defer label generation)
            const tickInfo = {
                timestamp: currentTime,
                x: xPosition,
                interval: optimalTickInterval,
                previousLabelInfo: previousLabelInfo
            };

            rawTicks.push(tickInfo);
        }

        // Move to next tick position
        currentTime = currentTime + optimalTickInterval;
    }

    // ================================
    // 7. POST-PROCESSING & OPTIMIZATION
    // ================================

    // OPTIMIZATION 8: Ensure minimum spacing before label generation
    const spacedTicks = ensureMinimumSpacingOptimized(rawTicks, minSpacingPixels);

    // OPTIMIZATION 7: Delay label formatting until after filtering
    const finalTicks = [];
    let prevLabelInfo = null;

    for (const tickInfo of spacedTicks) {
        // OPTIMIZATION 1: Create Date object once per tick
        const date = new Date(tickInfo.timestamp * 1000);

        // Generate label with reused Date object
        const labelInfo = generateTickLabelOptimized(date, tickInfo.timestamp, tickInfo.interval, options, prevLabelInfo);

        const tick = {
            label: labelInfo.text,
            x: tickInfo.x,
            timestamp: tickInfo.timestamp,
            type: labelInfo.type || null
        };

        finalTicks.push(tick);
        prevLabelInfo = labelInfo;
    }

    // OPTIMIZATION 4: Optimize UI-friendly label removal with forward loop
    if (options.labelType === LABEL_TYPE.UI_FRIENDLY) {
        optimizeUIFriendlyLabelsOptimized(finalTicks, optimalTickInterval, parsedRange);
    }

    // Validate final output
    if (finalTicks.length === 0) {
        return createFallbackTicks(actualTimeRange, canvasDimensions.width, options);
    }

    // Performance profiling end
    const endTime = performance.now();
    if (typeof console !== 'undefined' && console.log) {
        console.log(`Tick generation took ${(endTime - startTime).toFixed(2)}ms`);
    }

    return finalTicks;
}

// ================================
// OPTIMIZED HELPER FUNCTIONS
// ================================

function calculateEstimatedLabelWidth(textSize, labelType, parsedRange) {
    if (labelType === LABEL_TYPE.STANDARD) {
        if (parsedRange.unit === 'minutes' || parsedRange.unit === 'hours') {
            return textSize * 5; // "HH:MM"
        } else {
            return textSize * 8; // "DD/MM/YY"
        }
    } else { // UI_FRIENDLY
        return textSize * 4; // "MMM", "DD", "HH"
    }
}

function determineTargetTickCount(minMaxTicks, maxPossible, parsedRange) {
    if (minMaxTicks === 'auto') {
        // Smart defaults based on time range
        switch (parsedRange.unit) {
            case 'minutes':
            case 'hours':
                return Math.min(8, maxPossible);
            case 'days':
                if (parsedRange.value <= 5) {
                    return Math.min(parsedRange.value, maxPossible);
                } else {
                    return Math.min(7, maxPossible);
                }
            case 'weeks':
                return Math.min(7, maxPossible);
            case 'months':
                return Math.min(12, maxPossible);
            case 'years':
                return Math.min(5, maxPossible);
            default:
                return Math.min(6, maxPossible);
        }
    } else {
        return Math.min(minMaxTicks, maxPossible);
    }
}

// OPTIMIZATION 5: Binary search for interval selection
function selectOptimalTickIntervalBinary(timeSpan, targetTicks, intervalHierarchy) {
    const idealInterval = timeSpan / Math.max(targetTicks - 1, 1);

    let left = 0;
    let right = intervalHierarchy.length - 1;
    let result = intervalHierarchy[right]; // fallback to largest

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        const interval = intervalHierarchy[mid];

        if (interval >= idealInterval) {
            result = interval;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return result;
}

function alignTimeToInterval(timestamp, interval) {
    const date = new Date(timestamp * 1000);

    switch (interval) {
        case TICK_INTERVALS.MINUTE_1:
        case TICK_INTERVALS.MINUTE_2:
        case TICK_INTERVALS.MINUTE_5:
        case TICK_INTERVALS.MINUTE_10:
        case TICK_INTERVALS.MINUTE_15:
        case TICK_INTERVALS.MINUTE_30:
            return roundDownToMinuteBoundary(timestamp, interval / 60);

        case TICK_INTERVALS.HOUR_1:
        case TICK_INTERVALS.HOUR_2:
        case TICK_INTERVALS.HOUR_4:
        case TICK_INTERVALS.HOUR_6:
        case TICK_INTERVALS.HOUR_12:
            return roundDownToHourBoundary(timestamp, interval / 3600);

        case TICK_INTERVALS.DAY_1:
        case TICK_INTERVALS.DAY_5:
            return startOfDay(timestamp);

        case TICK_INTERVALS.WEEK_1:
        case TICK_INTERVALS.WEEK_2:
            return startOfWeek(timestamp);

        case TICK_INTERVALS.MONTH_1:
            return startOfMonth(timestamp);

        default:
            return timestamp;
    }
}

function roundDownToMinuteBoundary(timestamp, minuteInterval) {
    const date = new Date(timestamp * 1000);
    const minutes = date.getMinutes();
    const alignedMinutes = Math.floor(minutes / minuteInterval) * minuteInterval;

    date.setMinutes(alignedMinutes);
    date.setSeconds(0);
    date.setMilliseconds(0);

    return Math.floor(date.getTime() / 1000);
}

function roundDownToHourBoundary(timestamp, hourInterval) {
    const date = new Date(timestamp * 1000);
    const hours = date.getHours();
    const alignedHours = Math.floor(hours / hourInterval) * hourInterval;

    date.setHours(alignedHours);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);

    return Math.floor(date.getTime() / 1000);
}

function startOfDay(timestamp) {
    const date = new Date(timestamp * 1000);
    date.setHours(0, 0, 0, 0);
    return Math.floor(date.getTime() / 1000);
}

function startOfWeek(timestamp) {
    const date = new Date(timestamp * 1000);
    const day = date.getDay();
    const diff = date.getDate() - day + (day === 0 ? -6 : 1); // Monday as first day
    date.setDate(diff);
    date.setHours(0, 0, 0, 0);
    return Math.floor(date.getTime() / 1000);
}

function startOfMonth(timestamp) {
    const date = new Date(timestamp * 1000);
    date.setDate(1);
    date.setHours(0, 0, 0, 0);
    return Math.floor(date.getTime() / 1000);
}

// OPTIMIZATION 1: Accept pre-created Date object to avoid repeated creation
function generateTickLabelOptimized(date, timestamp, interval, options, previousLabelInfo) {
    if (options.labelType === LABEL_TYPE.STANDARD) {
        return generateStandardLabelOptimized(date, interval, options);
    } else {
        return generateUIFriendlyLabelOptimized(date, interval, options, previousLabelInfo);
    }
}

// OPTIMIZATION 6: Use Intl formatters with caching
function generateStandardLabelOptimized(date, interval, options) {
    if (interval < TICK_INTERVALS.DAY_1) {
        // Show time for intraday intervals
        const timeFormatter = getFormatter(options.locale, {
            hour: '2-digit',
            minute: '2-digit',
            hour12: false
        });
        return {
            text: timeFormatter.format(date),
            type: UI_LABEL_TYPES.HOUR
        };
    } else {
        // Show date for daily and longer intervals
        const dateFormatter = getFormatter(options.locale, {
            day: '2-digit',
            month: '2-digit',
            year: '2-digit'
        });
        return {
            text: dateFormatter.format(date),
            type: UI_LABEL_TYPES.DAY
        };
    }
}

function generateUIFriendlyLabelOptimized(date, interval, options, previousLabelInfo) {
    // Determine what level of detail to show based on interval
    if (interval < TICK_INTERVALS.HOUR_1) {
        // Minutes level
        if (isStartOfHour(date)) {
            return { text: formatHour(date), type: UI_LABEL_TYPES.HOUR };
        } else {
            return { text: formatMinute(date), type: UI_LABEL_TYPES.MINUTE };
        }
    } else if (interval < TICK_INTERVALS.DAY_1) {
        // Hours level
        if (isStartOfDay(date)) {
            return { text: formatDay(date), type: UI_LABEL_TYPES.DAY };
        } else {
            return { text: formatHour(date), type: UI_LABEL_TYPES.HOUR };
        }
    } else if (interval < TICK_INTERVALS.MONTH_1) {
        // Days level
        if (isStartOfMonth(date)) {
            return { text: formatMonth(date), type: UI_LABEL_TYPES.MONTH };
        } else if (isStartOfWeek(date) && interval >= TICK_INTERVALS.WEEK_1) {
            return { text: formatDay(date), type: UI_LABEL_TYPES.DAY };
        } else {
            return { text: formatDay(date), type: UI_LABEL_TYPES.DAY };
        }
    } else {
        // Months and longer
        if (isStartOfYear(date)) {
            return { text: formatYear(date), type: UI_LABEL_TYPES.YEAR };
        } else {
            return { text: formatMonth(date), type: UI_LABEL_TYPES.MONTH };
        }
    }
}

function formatHour(date) {
    return date.getHours().toString().padStart(2, '0');
}

function formatMinute(date) {
    return date.getMinutes().toString().padStart(2, '0');
}

function formatDay(date) {
    return date.getDate().toString().padStart(2, '0');
}

function formatMonth(date) {
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    return months[date.getMonth()];
}

function formatYear(date) {
    return date.getFullYear().toString();
}

function isStartOfHour(date) {
    return date.getMinutes() === 0 && date.getSeconds() === 0;
}

function isStartOfDay(date) {
    return date.getHours() === 0 && date.getMinutes() === 0 && date.getSeconds() === 0;
}

function isStartOfWeek(date) {
    return date.getDay() === 1 && isStartOfDay(date); // Monday
}

function isStartOfMonth(date) {
    return date.getDate() === 1 && isStartOfDay(date);
}

function isStartOfYear(date) {
    return date.getMonth() === 0 && isStartOfMonth(date);
}

// OPTIMIZATION 4: Forward loop to avoid splice performance issues
function optimizeUIFriendlyLabelsOptimized(ticks, interval, parsedRange) {
    if (ticks.length <= 1) return ticks;

    const filteredTicks = [];

    for (let i = 0; i < ticks.length; i++) {
        const currentTick = ticks[i];
        const shouldKeep = i === 0 ||
            currentTick.type !== ticks[i - 1].type ||
            currentTick.type === UI_LABEL_TYPES.DAY ||
            currentTick.type === UI_LABEL_TYPES.HOUR;

        if (shouldKeep) {
            filteredTicks.push(currentTick);
        }
    }

    // Replace original array contents
    ticks.length = 0;
    ticks.push(...filteredTicks);
}

// OPTIMIZATION 8: Optimized spacing check that works with raw tick info
function ensureMinimumSpacingOptimized(rawTicks, minSpacing) {
    if (rawTicks.length <= 1) return rawTicks;

    const result = [rawTicks[0]];

    for (let i = 1; i < rawTicks.length; i++) {
        const lastTick = result[result.length - 1];
        if (rawTicks[i].x - lastTick.x >= minSpacing) {
            result.push(rawTicks[i]);
        }
    }

    return result;
}

function createFallbackTicks(timeRange, canvasWidth, options) {
    // Create minimal fallback ticks at start and end
    const startDate = new Date(timeRange.start * 1000);
    const endDate = new Date(timeRange.end * 1000);

    const timeFormatter = getFormatter(options.locale, {
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
    });

    return [
        {
            label: timeFormatter.format(startDate),
            x: 0,
            timestamp: timeRange.start,
            type: UI_LABEL_TYPES.HOUR
        },
        {
            label: timeFormatter.format(endDate),
            x: canvasWidth,
            timestamp: timeRange.end,
            type: UI_LABEL_TYPES.HOUR
        }
    ];
}

// File: src/components/Drawing/Angleshape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface AngleShapeArgs {
    x0: number,
    y0: number,
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    color?: string,
    lineWidth?: number
}


export class AngleShape implements IDrawingShape {

    constructor(
        public x0: number,
        public y0: number,
        public x1: number,
        public y1: number,
        public x2: number,
        public y2: number,
        public color: string = 'teal',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {

        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.x0, this.y0);
        ctx.lineTo(this.x1, this.y1);
        ctx.moveTo(this.x0, this.y0);
        ctx.lineTo(this.x2, this.y2);
        ctx.stroke();
        const angleDeg = this.calculateAngle();
    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        return this.isPointNearLine(x, y, this.x0, this.y0, this.x1, this.y1, tolerance) ||
            this.isPointNearLine(x, y, this.x0, this.y0, this.x2, this.y2, tolerance);
    }

    private isPointNearLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, tolerance: number): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }

    private calculateAngle(): number {
        const v1 = {x: this.x1 - this.x0, y: this.y1 - this.y0};
        const v2 = {x: this.x2 - this.x0, y: this.y2 - this.y0};
        const dot = v1.x * v2.x + v1.y * v2.y;
        const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
        const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
        const cos = dot / (mag1 * mag2);
        return Math.acos(cos) * (100 / Math.PI);
    }
}

// File: src/components/Drawing/ArrowShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface ArrowShapeArgs {
    fromX: number,
    fromY: number,
    toX: number,
    toY: number,
    color?: string,
    lineWidth?: number
}

export class ArrowShape implements IDrawingShape {

    constructor(
        public fromX: number,
        public fromY: number,
        public toX: number,
        public toY: number,
        public color: string = 'black',
        public lineWidth: number = 2
    ) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        const headLength = 10;
        const dx = this.toX - this.fromX;
        const dy = this.toY - this.fromY;
        const angle = Math.atan2(dy, dx);

        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.fromX, this.fromY);
        ctx.lineTo(this.toX, this.toY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(this.toX, this.toY);
        ctx.lineTo(this.toX - headLength * Math.cos(angle - Math.PI / 6), this.toY - headLength * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(this.toX - headLength * Math.cos(angle + Math.PI / 6), this.toY - headLength * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(this.toX, this.toY);
        ctx.fillStyle = this.color;
        ctx.fill();

    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        return this.isPointNearLine(x, y, this.fromX, this.fromY, this.toX, this.toY, tolerance);
    }

    private isPointNearLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, tolerance: number): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }

}

// File: src/components/Drawing/CircleShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface CircleShapeArgs {
    centerX: number,
    centerY: number,
    radius: number,
    color?: string,
    lineWidth?: number
}

export class CircleShape implements IDrawingShape {
    constructor(
        public centerX: number,
        public centerY: number,
        public radius: number,
        public color: string = 'black',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.arc(this.centerX, this.centerY, this.radius, 0, Math.PI * 2);
    }

    isHit(x: number, y: number): boolean {
        const dx = x - this.centerX;
        const dy = y - this.centerY;
        return Math.sqrt(dx * dx + dy * dy) <= this.radius + this.lineWidth / 2;
    }
}

// File: src/components/Drawing/CustomSymbolShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface CustomSymbolShapeArgs {
    x: number,
    y: number,
    symbol: string,
    size: number,
    color: string
}

export class CustomSymbolShape implements IDrawingShape {

    constructor(
        public x: number,
        public y: number,
        public symbol: string = '*',
        public size: number = 24,
        public color: string = 'black') {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        ctx.fillStyle = this.color;
        ctx.font = `${this.size}px Arial`;
        ctx.fillText(this.symbol, this.x, this.y);
    }

    isHit(x: number, y: number): boolean {
        const halfSize = this.size / 2;
        return (
            x >= this.x - halfSize &&
            x <= this.x + halfSize &&
            y >= this.y - halfSize &&
            y <= this.y + halfSize
        );
    }

}

// File: src/components/Drawing/IDrawingShape.ts
export interface IDrawingShape {
    draw(ctx: CanvasRenderingContext2D): void;
    isHit(x: number, y: number): boolean;
}

// File: src/components/Drawing/LineShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface LineShapeArgs {
    startX: number,
    startY: number,
    endX: number,
    endY: number,
    color?: string,
    lineWidth?: number
}

export class LineShape implements IDrawingShape {
    constructor(
        public startX: number,
        public startY: number,
        public endX: number,
        public endY: number,
        public color: string = 'black',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.startX, this.startY);
        ctx.lineTo(this.endX, this.endY);
        ctx.stroke();
    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        return this.isPointNearLine(x, y, this.startX, this.startY, this.endX, this.endY, tolerance);
    }

    private isPointNearLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, tolerance: number): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }
}

// File: src/components/Drawing/Polyline.ts
import {IDrawingShape} from "./IDrawingShape.ts";

interface Point {
    x: number,
    y: number
}

export interface PolylineShapeArgs {
    points: Point[],
    color?: string,
    lineWidth?: number
}


export class Polyline implements IDrawingShape {

    constructor(
        public points: Point[],
        public color: string = 'navy',
        public lineWidth: number = 2
    ) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        if (this.points?.length < 2) return;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.points[0].x, this.points[0].y);
        this.points.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
        ctx.stroke();
    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        for (let i = 0; i < this.points.length - 1; i++) {
            const p1 = this.points[i];
            const p2 = this.points[i + 1];
            if (this.isPointNearLine(x, y, p1.x, p1.y, p2.x, p2.y, tolerance)) {
                return true;
            }
        }
        return false;
    }

    private isPointNearLine(
        px: number, py: number,
        x1: number, y1: number,
        x2: number, y2: number,
        tolerance: number
    ): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }
}

// File: src/components/Drawing/RectangleShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface RectangleShapeArgs {
    x: number,
    y: number,
    width: number,
    height: number,
    color?: string,
    lineWidth?: number
}


export class RectangleShape implements IDrawingShape {
    constructor(
        public x: number,
        public y: number,
        public width: number,
        public height: number,
        public color: string = 'blue',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.strokeRect(this.x, this.y, this.width, this.height);
    }

    isHit(x: number, y: number): boolean {
        return (
            x >= this.x &&
            x <= this.x + this.width &&
            y >= this.y &&
            y <= this.y + this.height
        );
    }
}

// File: src/components/Drawing/TriangleShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface TriangleShapeArgs {
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    x3: number,
    y3: number,
    color?: string,
    lineWidth?: number
}


export class TriangleShape implements IDrawingShape {

    constructor(
        public x1: number,
        public y1: number,
        public x2: number,
        public y2: number,
        public x3: number,
        public y3: number,
        public color: string = 'black',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {

        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.x1, this.y1);
        ctx.lineTo(this.x2, this.y2);
        ctx.lineTo(this.x3, this.y3);
        ctx.closePath();
        ctx.stroke();
    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        return (
            this.isPointNearLine(x, y, this.x1, this.y1, this.x2, this.y2, tolerance) ||
            this.isPointNearLine(x, y, this.x2, this.y2, this.x3, this.y3, tolerance) ||
            this.isPointNearLine(x, y, this.x3, this.y3, this.x1, this.y1, tolerance)
        );
    }

    private isPointNearLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, tolerance: number): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }
}

// File: src/components/Drawing/types.ts
import {Mode} from "../../contexts/ModeContext.tsx";

export type Drawing = {
    mode: Mode;
    args: any; // ◊†◊ô◊™◊ü ◊ú◊î◊ó◊ú◊ô◊£ ◊ë-type ◊û◊ì◊ï◊ô◊ß ◊ô◊ï◊™◊® ◊ê◊ù ◊ô◊©
}

// File: src/components/Toolbar/ModeButton.tsx


import React from 'react';
import { Mode } from '../../contexts/ModeContext';

interface ModeButtonProps {
  mode: Mode;
  currentMode: Mode;
  onClick: (mode: Mode) => void;
  label: string;
}

const ModeButton: React.FC<ModeButtonProps> = ({ mode, currentMode, onClick, label }) => {
  const selected = mode === currentMode;
  return (
    <button
      className={selected ? 'selected' : ''}
      onClick={() => onClick(mode)}
    >
      {label}
    </button>
  );
};

export default ModeButton;

// File: src/components/Toolbar/SettingsToolbar.tsx
import React from 'react';
import '../../styles/SettingsToolbar.scss';
export const SettingsToolbar: React.FC = () => {
    const handleDownload = () => {
        const canvas = document.querySelector('Canvas');
        if (!canvas) return;
        const link = document.createElement('a');
        link.download = 'chart-snapshot.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
    };

    return (
        <div className={'settings-toolbar'}>
            <input type="text" placeholder="Symbol"/>
            <select>
                <option value="1m">1 Min</option>
                <option value="5m">5 Min</option>
                <option value="1h">1 Hour</option>
                <option value="1d">1 Day</option>
            </select>
            <select>
                <option value="50">50 Bars</option>
                <option value="100">100 Bars</option>
                <option value="200">200 Bars</option>
            </select>
            <select>
                <option value="candlestick">Candlestick</option>
                <option value="line">Line</option>
            </select>
            <button onClick={handleDownload}>üì∏ Snapshot</button>
            <button>‚öôÔ∏è Settings</button>
        </div>
    );
};

// File: src/components/Toolbar/Toolbar.tsx
import React from 'react';
import { Mode, useMode } from '../../contexts/ModeContext';
import ModeButton from './ModeButton';
import '../../styles/Toolbar.scss';

export const Toolbar: React.FC = () => {
  const { mode, setMode } = useMode();

  return (
    <div className={'toolbar-container'}>
      <div className={'toolbar'}>
        <ModeButton mode={Mode.drawLine} currentMode={mode} onClick={setMode} label="D Line" />
        <ModeButton mode={Mode.drawRectangle} currentMode={mode} onClick={setMode} label="D Rect" />
        <ModeButton mode={Mode.drawCircle} currentMode={mode} onClick={setMode} label="D Cir" />
        <ModeButton mode={Mode.drawTriangle} currentMode={mode} onClick={setMode} label="D Triangle" />
        <ModeButton mode={Mode.drawAngle} currentMode={mode} onClick={setMode} label="D Angle" />
        <ModeButton mode={Mode.select} currentMode={mode} onClick={setMode} label="Select" />
        <ModeButton mode={Mode.editShape} currentMode={mode} onClick={setMode} label="Edit" />
      </div>
    </div>
  );
};

// File: src/contexts/ModeContext.tsx
import React, {createContext, useContext, useState} from 'react';

export enum Mode {
    none,
    drawLine,
    drawRectangle,
    drawCircle,
    drawTriangle,
    drawAngle,
    select,
    editShape,
    drawPolyline,
    drawArrow,
    drawCustomSymbol,
    drawText
}

interface ModeContextProps {
    mode: Mode;
    setMode: (mode: Mode) => void;
}

const ModeContext = createContext<ModeContextProps | undefined>(undefined);

export const ModeProvider: React.FC<{ children: React.ReactNode }> = ({children}) => {
    const [mode, setModeState] = useState<Mode>(Mode.none);

    const setMode = (newMode: Mode) => {
        setModeState(prev => (prev === newMode ? Mode.none : newMode));
    };

    return (
        <ModeContext.Provider value={{mode, setMode}}>
            {children}
        </ModeContext.Provider>
    );
};

export const useMode = (): ModeContextProps => {
    const context = useContext(ModeContext);
    if (!context) {
        throw new Error('useMode must be used within a ModeProvider');
    }
    return context;
};

// File: src/index.css
@tailwind base;
@tailwind components;
@tailwind utilities;

// File: src/main.ts


// File: src/main.tsx
import './index.css'; //

import React from 'react';
import ReactDOM from 'react-dom/client';
import {App} from './components/App';
import {ModeProvider} from './contexts/ModeContext';

const root = document.getElementById('root') as HTMLElement;

ReactDOM.createRoot(root).render(
    <React.StrictMode>
        <ModeProvider>
            <App/>
        </ModeProvider>
    </React.StrictMode>
);

// File: src/store/useChartStore.ts
import {create} from 'zustand';
import type {Candle} from '../types/Candle.ts';
import {} from '../types/Candle.ts'
import {TimeRange} from '../types/Graph.ts';
import {useState} from "react";


interface ChartState {
    numberOfXTicks: number;
    numberOfYTicks: number;
    timeFormat: string;
    timeFormat12h: boolean;
    xAxisHeight: number;
    yAxisWidth: number;
    setXAxisHeight: (height: number) => void;
    setYAxisWidth: (width: number) => void;
    setCanvasWidth: (width: number) => void;
    setCanvasHeight: (height: number) => void;
    setNumberOfXTicks: (n: number) => void;
    setNumberOfYTicks: (n: number) => void;
    setTimeFormat: (format: string) => void;
    setTimeFormat12h: (value: boolean) => void;
    setVisibleRange: (range: { start: number; end: number }) => void;

    // Drawing state
    drawings: any[]; // ◊ê◊§◊©◊® ◊ú◊î◊ó◊ú◊ô◊£ ◊ú◊°◊ï◊í ◊û◊ì◊ï◊ô◊ß ◊ô◊ï◊™◊®
    setDrawings: (drawings: any[] | ((prev: any[]) => any[])) => void;
    selectedIndex: number | null;
    setSelectedIndex: (index: number | null) => void;

    // Mode
    mode: string;
    setMode: (mode: string) => void;

    // Is Drawing
    isDrawing: boolean;
    setIsDrawing: (val: boolean) => void;

    // Points
    startPoint: { x: number; y: number } | null;
    setStartPoint: (point: { x: number; y: number } | null) => void;
    currentPoint: { x: number; y: number } | null;
    setCurrentPoint: (point: { x: number; y: number } | null) => void;

    stepX: number;
    stepY: number;
    strokeStyle: string;
    margin: number;

    setStepX: (value: number) => void;
    setStepY: (value: number) => void;
    setStrokeStyle: (value: string) => void;
    setPadding: (value: number) => void;

    minPrice: number;
    maxPrice: number;
    setMinPrice: (value: number) => void;
    setMaxPrice: (value: number) => void;

    yAxisPosition: 'left' | 'right';
    setYAxisPosition: (position: 'left' | 'right') => void;

    priceDecimalPlaces: number;
    setPriceDecimalPlaces: (value: number) => void;

    decimalSeparator: string;
    setDecimalSeparator: (value: string) => void;

    thousandSeparator: string;
    setThousandSeparator: (value: string) => void;

    currencySymbol: string;
    setCurrencySymbol: (value: string) => void;

    currencySymbolPosition: 'before' | 'after';
    setCurrencySymbolPosition: (value: 'before' | 'after') => void;

    safeCandles: Candle[];
    visibleCandles: Candle[];
    candlesToUse: Candle[];
    visibleRange: TimeRange;

    setCandlesAndVisibleRange: (candles: Candle[], visibleRange: TimeRange) => void;

    timeDetailLevel: 'auto' | 'low' | 'medium' | 'high';
    setTimeDetailLevel: (level: 'auto' | 'low' | 'medium' | 'high') => void;
}

export const useChartStore = create<ChartState>((set) => ({
    numberOfXTicks: 5,
    numberOfYTicks: 5,
    timeFormat: 'YYYY/MM/DD',
    timeFormat12h: false, // false = 24 ◊©◊¢◊ï◊™, true = 12 ◊©◊¢◊ï◊™ AM/PM
    xAxisHeight: 40,
    yAxisWidth: 40,
    setXAxisHeight: (height) => set({xAxisHeight: height}),
    setYAxisWidth: (width) => set({yAxisWidth: width}),
    stepX: 50,
    stepY: 50,
    strokeStyle: '#eee',
    padding: 15,
    setCandles: (candles) => set({candles}),
    candles: [],
    visibleRange: {start: Date.now() - 365 * 24 * 60 * 60 * 1000, end: Date.now()},
    setVisibleRange: (range) => set({visibleRange: range}),
    setCanvasWidth: (width) => set({canvasWidth: width}),
    setCanvasHeight: (height) => set({canvasHeight: height}),
    setNumberOfXTicks: (n) => set({numberOfXTicks: n}),
    setNumberOfYTicks: (n) => set({numberOfYTicks: n}),
    setTimeFormat: (format) => set({timeFormat: format}),
    setTimeFormat12h: (value) => set({timeFormat12h: value}),

    drawings: [],
    setDrawings: (update) => set(state => ({
        drawings: typeof update === 'function' ? update(state.drawings) : update
    })),
    selectedIndex: null,
    setSelectedIndex: (index) => set({selectedIndex: index}),

    mode: 'none',
    setMode: (mode) => set({mode}),

    isDrawing: false,
    setIsDrawing: (val) => set({isDrawing: val}),

    startPoint: null,
    setStartPoint: (point) => set({startPoint: point}),

    currentPoint: null,
    setCurrentPoint: (point) => set({currentPoint: point}),

    setStepX: (value) => set({stepX: value}),
    setStepY: (value) => set({stepY: value}),
    setStrokeStyle: (value) => set({strokeStyle: value}),
    setMargin: (value) => set({margin: value}),

    minPrice: 0,
    maxPrice: 100,
    setMinPrice: (value) => set({minPrice: value}),
    setMaxPrice: (value) => set({maxPrice: value}),

    yAxisPosition: 'left',
    setYAxisPosition: (position) => set({yAxisPosition: position}),

    priceDecimalPlaces: 2,
    setPriceDecimalPlaces: (value) => set({priceDecimalPlaces: value}),

    decimalSeparator: '.',
    setDecimalSeparator: (value) => set({decimalSeparator: value}),

    thousandSeparator: ',',
    setThousandSeparator: (value) => set({thousandSeparator: value}),

    currencySymbol: '$',
    setCurrencySymbol: (value) => set({currencySymbol: value}),

    currencySymbolPosition: 'before',
    setCurrencySymbolPosition: (value) => set({currencySymbolPosition: value}),

    safeCandles: [],
    visibleCandles: [],
    candlesToUse: [],
    setCandlesAndVisibleRange: (candles, visibleRange) => set(state => {
        const safeCandles = candles || [];
        const visibleCandles = safeCandles.filter(
            c => visibleRange && c.t >= visibleRange.start && c.t <= visibleRange.end
        );
        const candlesToUse = visibleCandles.length > 0 ? visibleCandles : safeCandles;
        const prices = candlesToUse.length > 0
            ? candlesToUse.flatMap(c => [c.h, c.l])
            : [];
        const maxPrice = prices.length > 0 ? Math.max(...prices) : 1;
        const minPrice = prices.length > 0 ? Math.min(...prices) : 0;
        return {
            safeCandles,
            visibleRange,
            visibleCandles,
            candlesToUse,
            minPrice,
            maxPrice
        };
    }),

    timeDetailLevel: 'auto',
    setTimeDetailLevel: (level) => set({timeDetailLevel: level}),
}));

// File: src/styles/App.scss
//make the html file to cover the whole screen
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden; /* ◊ú◊û◊†◊ï◊¢ ◊í◊ú◊ô◊ú◊î ◊û◊ô◊ï◊™◊®◊™ */
}

#root {
  height: calc(100% - 4px); /* ◊ú◊î◊ï◊®◊ô◊ì ◊í◊ï◊ë◊î ◊©◊ú ◊î-toolbar */
  width: calc(100% - 4px); /* ◊ú◊î◊ï◊®◊ô◊ì ◊®◊ï◊ó◊ë ◊©◊ú ◊î-toolbar */

  margin: 2px;
  padding: 0;
  display: flex;
  flex-direction: column;
  overflow: hidden; /* ◊ú◊û◊†◊ï◊¢ ◊í◊ú◊ô◊ú◊î ◊û◊ô◊ï◊™◊®◊™ */
}

// make the app container to cover the whole screen
.main-app-window {
  display: flex;
  flex: 1 0 auto; /* ◊û◊ê◊§◊©◊® ◊ú◊û◊®◊õ◊ô◊ë ◊ú◊î◊™◊§◊©◊ò ◊ú◊í◊ï◊ë◊î ◊ï◊ú◊®◊ï◊ó◊ë ◊©◊ú ◊î◊ó◊ú◊ï◊ü */
  flex-direction: column;
  position: relative;
  height: 100%;
  width: 100%;
  box-sizing: border-box;
  overflow: hidden; /* ◊ú◊û◊†◊ï◊¢ ◊í◊ú◊ô◊ú◊î ◊û◊ô◊ï◊™◊®◊™ */
}

.settings-area {
  display: flex;
  flex-direction: row;
  height: 30px;
  width: 100%;
}

.lower-container {
  height: calc(100% - 40px);
  width: 100%;
  display: flex;
  flex-direction: row;
  overflow: hidden; /* ◊ú◊û◊†◊ï◊¢ ◊í◊ú◊ô◊ú◊î ◊ê◊ï◊§◊ß◊ô◊™ */
}

.toolbar-container {
  width: 40px; /* ◊®◊ï◊ó◊ë ◊°◊®◊í◊ú ◊î◊õ◊ú◊ô◊ù */
  height: 100%;
  flex-shrink: 0; /* ◊ú◊û◊†◊ï◊¢ ◊õ◊ô◊ï◊ï◊• */
}

// File: src/styles/Canvas/Axes.scss


// File: src/styles/Canvas/ChartCanves.scss
.chart-canvas-container {
  flex-grow: 1;
  width: calc(100% - 40px); /* ◊ú◊î◊ï◊®◊ô◊ì ◊®◊ï◊ó◊ë ◊©◊ú ◊î-toolbar */
  height: 100%;
  position: relative;
  display: block;
  max-height: 100%;
}

// File: src/styles/Canvas/ChartStage.scss
//.canvas-container canvas {
//  position: absolute;
//  top: 0;
//  left: 0;
//  z-index: 0;
//}


html, body, #root {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
}


.chart-stage-container {
  width: 100%;
  height: 100%;
}



// File: src/styles/Canvas/Grid.scss


// File: src/styles/Drawing.scss


// File: src/styles/Overlays.scss


// File: src/styles/SettingsToolbar.scss

.settings-toolbar {
  background: #ddd;
  display: flex;
  height: 100%;
  width: 100%;
  justify-content: start;
  align-content: center;
  align-items: center;

  input, select, button {
    height: 100%;
    border-radius: 3px;
    border-width: 1px;
    width: fit-content;
    font-size: 11px;
    padding: 0 5px;
  }

  input {
    height: calc(100% - 2px);
    width: 100px;
  }

}

// File: src/styles/Toolbar.scss
@use '../styles/variables' as v;

.toolbar-container {
  display: flex;
  flex-grow: 0;
  flex-shrink: 0;
  width: v.$toolbar-width;
  background-color: #ddd;
  height: 100%;
}

.toolbar {
  width: v.$toolbar-width;
  height: 100%;
  display: grid;
  grid-column: 1;
  grid-auto-flow: row;
  grid-template-rows: auto;
  grid-template-columns: auto;
  align-content: start;

  button {
    display: flex;
    min-height: v.$toolbar-width;
    width: 100%;
    flex-grow: 1;
    padding: 0;
    overflow: hidden;
    text-align: center;
    font-size: 10px;

    &.selected {
      background-color: #333;
      color: #fff;
      border-left: 3px solid #007bff;
    }
  }
}

// File: src/styles/_variables.scss

$toolbar-width: 40px;

// File: src/types/Candle.ts
// ◊ò◊ô◊§◊ï◊° Candle ◊¢◊ù ◊©◊ì◊ï◊™ t, o, c, l, h
export interface Candle {
    t: number; // timestamp
    o: number; // open
    c: number; // close
    l: number; // low
    h: number; // high
}

export interface CandleWithIndex extends Candle {
    index: number; // index in the original array
}

// File: src/types/Graph.ts
export interface Tick {
    time: number;      // timestamp UNIX ◊ë◊û◊ô◊ú◊ô◊©◊†◊ô◊ï◊™
    label: string;     // ◊™◊¶◊ï◊í◊™ ◊î◊ò◊ô◊ß ◊õ◊ò◊ß◊°◊ò
}

export interface TimeRange {
    start: number; // timestamp ◊î◊™◊ó◊ú◊î
    end: number;   // timestamp ◊°◊ô◊ï◊ù
}

// File: src/types/chartStyleOptions.d.ts
// chartStyleOptions.ts

// Candles style
import {AxesPosition} from "./types.ts";

export interface CandleStyleOptions {
    upColor?: string;
    downColor?: string;
    borderColor?: string;
    borderWidth?: number;
    bodyWidthFactor?: number;
    spacingFactor?: number;
}

// Grid style
export interface GridStyleOptions {
    gridSpacing?: number;
    lineColor?: string;
    lineWidth?: number;
    lineDash?: number[];
}

// Axes style
export interface AxesStyleOptions {
    axisPosition?: AxesPosition;
    textColor?: string;
    font?: string;
    lineColor?: string;
    lineWidth?: number;
    numberLocale?: string;
    dateLocale?: string;
    numberFractionDigits?: number; // Number of decimal places to format axis values
}
export interface LineOverlayOptions{
    color?: string;
    lineWidth?: number;
    dashed?: boolean;
}
// Main Chart style options
export interface ChartStyleOptions {
    candles?: CandleStyleOptions;
    grid?: GridStyleOptions;
    axes?: AxesStyleOptions;
    lineOverlay?:LineOverlayOptions;
    backgroundColor?:string;
    // ◊ê◊§◊©◊® ◊ú◊î◊ï◊°◊ô◊£ ◊§◊î ◊¢◊ï◊ì (◊ú◊û◊©◊ú lineOverlay ◊ï◊õ◊ï')
}

// File: src/types/types.ts
import {ChartStyleOptions} from "./chartStyleOptions";

// Enum for Axis position
export enum AxesPosition {
    left = 'left',
    right = 'right',
}

// Base chart options
interface BaseChartOptions {
    theme?: 'light' | 'dark' | 'grey' | string;
    showOverlayLine?: boolean;
    style?: Partial<ChartStyleOptions>;
}

// Line chart data point
export interface LineData {
    time: number;
    value: number;
}

// Candlestick chart data point (full)
export interface CandleData {
    time: number;
    open: number;
    high: number;
    low: number;
    close: number;
}

// Candlestick chart data point (compact)
export interface CandleDataCompact {
    t: number;
    o: number;
    h: number;
    l: number;
    c: number;
}

// Line chart options
export interface LineChartOptions extends BaseChartOptions {
    type: 'line';
    data: LineData[];
}

// Candlestick chart options
export interface CandleChartOptions extends BaseChartOptions {
    type: 'candlestick';
    data: (CandleData | CandleDataCompact)[];
}

// Unified ChartOptions type
export type ChartOptions = LineChartOptions | CandleChartOptions;

// File: src/vite-env.d.ts
/// <reference types="vite/client" />


