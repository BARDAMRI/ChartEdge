// File: src/components/App.tsx
import React from 'react';
import {ChartStage} from './Canvas/ChartStage.tsx';
import {Toolbar} from './Toolbar/Toolbar.tsx';
import {SettingsToolbar} from './Toolbar/SettingsToolbar.tsx';
import '../styles/App.scss';

export const App: React.FC = () => {
    return (
        <div className={'main-app-window'}>
            <div className={'settings-area'}>
                <SettingsToolbar/>
            </div>
            <div className={'lower-container'}>
                <ChartStage/>
                <Toolbar/>
            </div>
        </div>
    );
};

// File: src/components/Canvas/Axes/XAxis.tsx
import React, {useEffect, useRef} from 'react';
import {useChartStore} from '../../../store/useChartStore.ts';
import {generateTimeTicks} from '../utils/generateTimeTicks.ts';

export default function XAxis() {
    const {
        canvasWidth,
        canvasHeight,
        padding,
        visibleRange,
        timeDetailLevel,
        timeFormat12h,
    } = useChartStore();

    const canvasRef = useRef<HTMLCanvasElement>(null);
    const dpr = window.devicePixelRatio || 1;
    const chartWidth = canvasWidth - 2 * padding;

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const width = canvas.clientWidth;
        const height = canvas.clientHeight;

        canvas.width = width * dpr;
        canvas.height = height * dpr;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, width, height);

        // Draw X-axis line
        ctx.strokeStyle = 'black';
        ctx.fillStyle = 'black';
        ctx.font = `${12 * dpr}px Arial`;
        ctx.textBaseline = 'top';
        ctx.textAlign = 'center';

        ctx.beginPath();
        ctx.moveTo(0, 5);
        ctx.lineTo(width, 5);
        ctx.stroke();

        // Generate and draw ticks
        const ticks = generateTimeTicks(
            visibleRange.start,
            visibleRange.end,
            chartWidth,
            timeDetailLevel,
            timeFormat12h
        );

        ticks.forEach(({time, label}) => {
            const x = padding + ((time - visibleRange.start) / (visibleRange.end - visibleRange.start)) * chartWidth;

            // Draw tick mark
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, 5);
            ctx.stroke();

            // Draw label
            ctx.fillText(label, x, 12);
        });
    }, [canvasWidth, canvasHeight, padding, visibleRange, timeDetailLevel, timeFormat12h, dpr]);

    return (
        <canvas
            ref={canvasRef}
            style={{
                display: 'block',
                position: 'relative',
                bottom: 0,
                left: 0,
                width: '100%',
                height: '40px',
                padding: 0,
                margin: 0
            }}
        />
    );
}


// File: src/components/Canvas/Axes/YAxis.tsx
import React, {useEffect, useRef} from 'react';
import {useChartStore} from '../../../store/useChartStore';

export default function YAxis({parentWidth = 0, parentHeight = 0}){
    const {
        canvasHeight,
        minPrice,
        maxPrice,
        numberOfYTicks,
        yAxisPosition,
        padding
    } = useChartStore();

    const canvasRef = useRef<HTMLCanvasElement>(null);
    const dpr = window.devicePixelRatio || 1;

    function calculateTicks(): { y: number; value: number }[] {
        const chartHeight = canvasHeight;
        const step = (maxPrice - minPrice) / (numberOfYTicks - 1);
        return Array.from({length: numberOfYTicks}).map((_, i) => {
            return {
                value: minPrice + i * step,
                y: chartHeight - (i / (numberOfYTicks - 1)) * chartHeight,
            };
        });
    }

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const width = parentWidth;
        const height = parentHeight;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = 'black';
        ctx.fillStyle = 'black';
        ctx.font = `${12 * dpr}px Arial`;
        ctx.textBaseline = 'middle';
        ctx.textAlign = yAxisPosition === 'left' ? 'right' : 'left';

        const chartHeight = height;
        const yAxisX = width ; //yAxisPosition === 'left' ? width
        ctx.beginPath();
        ctx.moveTo(yAxisX, chartHeight);
        ctx.lineTo(yAxisX, 0);
        ctx.stroke();

        const ticks = calculateTicks();
        ticks.forEach(({y, value}) => {
            ctx.beginPath();
            ctx.moveTo(yAxisX, y);
            ctx.lineTo(yAxisPosition === 'left' ? yAxisX - 5 : yAxisX + 5, y);
            ctx.stroke();

            const text = value.toFixed(2);
            const textWidth = ctx.measureText(text).width;
            const offsetX = yAxisPosition === 'left' ? yAxisX - 10 - textWidth : yAxisX + 10;

            ctx.fillText(text, offsetX, y);
        });
    }, [canvasHeight, minPrice, maxPrice, numberOfYTicks, yAxisPosition, dpr]);

    return (
        <canvas
            className={`y-canvas block absolute left-${ yAxisPosition === 'left' ? 0 : 'auto'} right-${yAxisPosition === 'right' ? 0 : 'auto'} top-0 bottom-0 z-10 pointer-events-none w-[100%] h-[100%]`}
            ref={canvasRef}
        />
    );
}

// File: src/components/Canvas/ChartCanvas.tsx
import React, { useRef, useEffect } from 'react';
import { Mode, useMode } from '../../contexts/ModeContext';
import { drawGrid } from './utils/drawGrid';
import { drawCandlesticks } from './utils/drawCandlesticks';
import { drawDrawings } from './utils/drawDrawings';
import { drawOverlay } from './utils/drawOverlay';
import { useChartStore } from '../../store/useChartStore';
import { TimeRange } from "../../types/Graph.ts";

interface ChartCanvasProps {
  width: number;
  height: number;
}

export const ChartCanvas: React.FC<ChartCanvasProps> = ({ width, height }) => {
  const mode = useMode().mode;
  const isDrawing = useChartStore(state => state.isDrawing);
  const setIsDrawing = useChartStore(state => state.setIsDrawing);
  const startPoint = useChartStore(state => state.startPoint);
  const setStartPoint = useChartStore(state => state.setStartPoint);
  const currentPoint = useChartStore(state => state.currentPoint);
  const setCurrentPoint = useChartStore(state => state.setCurrentPoint);
  const drawings = useChartStore(state => state.drawings);
  const setDrawings = useChartStore(state => state.setDrawings);
  const selectedIndex = useChartStore(state => state.selectedIndex);
  const setSelectedIndex = useChartStore(state => state.setSelectedIndex);
  const visibleRange = useChartStore(state => state.visibleRange);
  const setVisibleRange = useChartStore(state => state.setVisibleRange);
  const candlesToUse = useChartStore(state => state.candlesToUse);
  const padding = useChartStore(state => state.padding);
  const minPrice = useChartStore(state => state.minPrice);
  const maxPrice = useChartStore(state => state.maxPrice);
  const setCandlesAndVisibleRange = useChartStore(state => state.setCandlesAndVisibleRange);
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const xAxisHeight = useChartStore(state => state.xAxisHeight);

  // Initialize visibleRange in store if not set
  useEffect(() => {
    const now = Date.now();
    const oneYearAgo = now - 365 * 24 * 60 * 60 * 1000;
    const defaultVisibleRange: TimeRange = { start: oneYearAgo, end: now };
    if (!visibleRange || visibleRange.start === 0 || visibleRange.end === 0) {
      setVisibleRange(defaultVisibleRange);
    }
  }, [candlesToUse, visibleRange, setVisibleRange]);

  // Set candles and visibleRange in store
  useEffect(() => {
    setCandlesAndVisibleRange(candlesToUse, visibleRange || { start: 0, end: Date.now() });
  }, [candlesToUse, visibleRange, setCandlesAndVisibleRange]);

  // Mouse event handlers
  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!canvasRef.current) return;
    const rect = canvasRef.current!.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (mode === Mode.select) {
      for (let i = 0; i < drawings.length; i++) {
        const d = drawings[i];
        let shape = null;
        if (d.mode === Mode.drawLine) {
          // @ts-ignore
          shape = new LineShape(d.args.startX, d.args.startY, d.args.endX, d.args.endY);
        } else if (d.mode === Mode.drawRectangle) {
          // @ts-ignore
          shape = new RectangleShape(d.args.x, d.args.y, d.args.width, d.args.height);
        } else if (d.mode === Mode.drawCircle) {
          // @ts-ignore
          shape = new CircleShape(d.args.centerX, d.args.centerY, d.args.radius);
        }
        if (shape && shape.isHit(x, y)) {
          setSelectedIndex(i);
          return;
        }
      }
      setSelectedIndex(null);
      return;
    }

    if (mode !== Mode.none) {
      setStartPoint({ x, y });
      setIsDrawing(true);
    }
  };

  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDrawing || !startPoint || mode === Mode.none) return;
    if (!canvasRef.current) return;

    const rect = canvasRef.current!.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    setCurrentPoint({ x, y });
  };

  const handleMouseUp = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDrawing || !startPoint || mode === Mode.none) return;
    if (!canvasRef.current) return;

    const rect = canvasRef.current!.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    setDrawings(prev => {
      const newDrawing = {
        [Mode.drawLine]: () => ({
          mode: Mode.drawLine,
          args: {
            startX: startPoint.x,
            startY: startPoint.y,
            endX: x,
            endY: y,
          },
        }),
        [Mode.drawRectangle]: () => ({
          mode: Mode.drawRectangle,
          args: {
            x: startPoint.x,
            y: startPoint.y,
            width: x - startPoint.x,
            height: y - startPoint.y,
          },
        }),
        [Mode.drawCircle]: () => {
          const dx = x - startPoint.x;
          const dy = y - startPoint.y;
          const radius = Math.sqrt(dx * dx + dy * dy);
          return {
            mode: Mode.drawCircle,
            args: {
              centerX: startPoint.x,
              centerY: startPoint.y,
              radius,
            },
          };
        }
      };
      return newDrawing[mode] ? [...prev, newDrawing[mode]()] : prev;
    });

    setIsDrawing(false);
    setStartPoint(null);
    setCurrentPoint(null);
  };

  // Drawing effect
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    if (width === 0 || height === 0) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);

    ctx.clearRect(0, 0, width, height);

    drawGrid(ctx, width, height);
    drawCandlesticks(ctx, candlesToUse, visibleRange, padding, minPrice, maxPrice, width, height);
    drawDrawings(ctx, drawings, selectedIndex, width, height);
    drawOverlay(ctx, mode, isDrawing, startPoint, currentPoint, width, height);

  }, [
    width,
    height,
    candlesToUse,
    visibleRange,
    drawings,
    selectedIndex,
    mode,
    isDrawing,
    startPoint,
    currentPoint,
    padding,
    minPrice,
    maxPrice,
  ]);

  return (
    <div className="canvas-container relative" style={{ width: '100%', height: `calc(100% - ${xAxisHeight}px)` }}>
      <canvas
        ref={canvasRef}
        style={{ userSelect: 'none', display: 'block' }}
        width={width}
        height={height}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
      />
    </div>
  );
};

// File: src/components/Canvas/ChartStage.tsx
import React, { useRef } from 'react';
import { ChartCanvas } from './ChartCanvas';
import { useChartStore } from "../../store/useChartStore.ts";
import XAxis from "./Axes/XAxis.tsx";
import YAxis from "./Axes/YAxis.tsx";

export const ChartStage: React.FC = () => {
  const yAxisPosition = useChartStore(state => state.yAxisPosition);
  const padding = useChartStore(state => state.padding);

  const containerRef = useRef<HTMLDivElement | null>(null);

  return (
    <div
      ref={containerRef}
      className="chart-stage-container grid w-full h-full"
      style={{
        gridTemplateColumns: yAxisPosition === 'left' ? `40px 1fr` : `1fr 40px`,
        gridTemplateRows: `1fr 40px`,
        padding,
      }}
    >
      {yAxisPosition === 'left' && (
        <div className="right-y-axis-container relative">
          <YAxis containerRef={containerRef} />
        </div>
      )}

      <div className="canvas-axis-container relative">
        <ChartCanvas containerRef={containerRef} />
        <div className="x-axis-container absolute bottom-0 left-0 w-full">
          <XAxis containerRef={containerRef} />
        </div>
      </div>

      {yAxisPosition === 'right' && (
        <div className="left-y-axis-container relative">
          <YAxis containerRef={containerRef} />
        </div>
      )}
    </div>
  );
};

// File: src/components/Canvas/utils/drawCandlesticks.ts
import { Candle } from '../../../types/Candle';

export function drawCandlesticks(
  ctx: CanvasRenderingContext2D,
  candles: Candle[],
  visibleRange: { start: number; end: number },
  padding: number,
  minPrice: number,
  maxPrice: number,
  width: number,
  height: number
): void {
  const drawableWidth = width - 2 * padding;
  const drawableHeight = height - 2 * padding;

  const candleCount = visibleRange.end - visibleRange.start;
  if (candleCount <= 0) return;

  const candleSpacing = drawableWidth / candleCount;
  const candleWidth = candleSpacing * 0.6;

  const priceRange = maxPrice - minPrice;

  // 驻拽爪 专转 专 拽 Y 拽住
  const priceToY = (price: number) => {
    return padding + drawableHeight * (1 - (price - minPrice) / priceRange);
  };

  const visibleCandles = candles.slice(visibleRange.start, visibleRange.end);

  visibleCandles.forEach((candle, i) => {
    const x = padding + i * candleSpacing;
    const highY = priceToY(candle.h);
    const lowY = priceToY(candle.l);
    const openY = priceToY(candle.o);
    const closeY = priceToY(candle.c);

    const isUp = candle.c >= candle.o;

    ctx.strokeStyle = isUp ? 'green' : 'red';
    ctx.fillStyle = isUp ? 'green' : 'red';
    ctx.lineWidth = 1;

    // 爪专 -wick (拽 注 转转)
    ctx.beginPath();
    ctx.moveTo(x + candleWidth / 2, highY);
    ctx.lineTo(x + candleWidth / 2, lowY);
    ctx.stroke();

    // 爪专 祝 专
    const bodyY = Math.min(openY, closeY);
    const bodyHeight = Math.max(1, Math.abs(openY - closeY)); // 驻转 1 驻拽住 
    ctx.fillRect(x, bodyY, candleWidth, bodyHeight);
  });
}


// File: src/components/Canvas/utils/drawDrawings.ts


import { Drawing } from '../../Drawing/types';
import { LineShape } from '../../Drawing/LineShape';
import { RectangleShape } from '../../Drawing/RectangleShape';
import { CircleShape } from '../../Drawing/CircleShape';
import { TriangleShape } from '../../Drawing/TriangleShape';
import { AngleShape } from '../../Drawing/AngleShape';
import { Polyline } from '../../Drawing/Polyline';
import { ArrowShape } from '../../Drawing/ArrowShape';
import { CustomSymbolShape } from '../../Drawing/CustomSymbolShape';
import { Mode } from '../../../contexts/ModeContext';

export function drawDrawings(
  ctx: CanvasRenderingContext2D,
  drawings: Drawing[],
  selectedIndex: number | null,
  width: number,
  height: number
): void {
  drawings.forEach((d, index) => {
    ctx.beginPath();
    let shape = null;
    switch (d.mode) {
      case Mode.drawLine:
        shape = new LineShape(
          d.args.startX,
          d.args.startY,
          d.args.endX,
          d.args.endY
        );
        break;
      case Mode.drawRectangle:
        shape = new RectangleShape(
          d.args.x,
          d.args.y,
          d.args.width,
          d.args.height
        );
        break;
      case Mode.drawCircle:
        shape = new CircleShape(
          d.args.centerX,
          d.args.centerY,
          d.args.radius
        );
        break;
      case Mode.drawTriangle:
        shape = new TriangleShape(
          d.args.x1,
          d.args.y1,
          d.args.x2,
          d.args.y2,
          d.args.x3,
          d.args.y3
        );
        break;
      case Mode.drawAngle:
        shape = new AngleShape(
          d.args.x0,
          d.args.y0,
          d.args.x1,
          d.args.y1,
          d.args.x2,
          d.args.y2
        );
        break;
      case Mode.drawPolyline:
        shape = new Polyline(d.args.points);
        break;
      case Mode.drawArrow:
        shape = new ArrowShape(
          d.args.fromX,
          d.args.fromY,
          d.args.toX,
          d.args.toY
        );
        break;
      case Mode.drawCustomSymbol:
        shape = new CustomSymbolShape(
          d.args.x,
          d.args.y,
          d.args.symbol,
          d.args.size,
          d.args.color
        );
        break;
      default:
        break;
    }

    if (shape) {
      if (selectedIndex === index) {
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
      } else {
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
      }
      shape.draw(ctx);
      ctx.stroke();
    }
  });
}

// File: src/components/Canvas/utils/drawGrid.ts
export function drawGrid(ctx: CanvasRenderingContext2D, width: number, height: number) {
  const stepX = 50; // 专 驻拽  拽, 转 砖转
  const stepY = 50; // 专   拽, 转 砖转
  const strokeStyle = '#ccc'; // 爪注 拽, 转 砖转

  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = 1;

  // 拽爪转 专
  const xStart = 0;
  const xEnd = width;
  const yStart = 0;
  const yEnd = height;

  // 拽 
  for (let x = xStart; x <= xEnd; x += stepX) {
    ctx.beginPath();
    ctx.moveTo(x, yStart);
    ctx.lineTo(x, yEnd);
    ctx.stroke();
  }

  // 拽 驻拽
  for (let y = yStart; y <= yEnd; y += stepY) {
    ctx.beginPath();
    ctx.moveTo(xStart, y);
    ctx.lineTo(xEnd, y);
    ctx.stroke();
  }
}


// File: src/components/Canvas/utils/drawOverlay.ts
import { Mode } from '../../../contexts/ModeContext';

export function drawOverlay(
  ctx: CanvasRenderingContext2D,
  mode: Mode,
  isDrawing: boolean,
  startPoint: { x: number; y: number } | null,
  currentPoint: { x: number; y: number } | null,
  width: number,
  height: number
) {
  if (!isDrawing || !startPoint || !currentPoint) return;

  ctx.strokeStyle = 'blue';
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 5]); // 拽 拽

  ctx.beginPath();
  switch (mode) {
    case Mode.drawLine:
      ctx.moveTo(startPoint.x, startPoint.y);
      ctx.lineTo(currentPoint.x, currentPoint.y);
      break;

    case Mode.drawRectangle:
      ctx.rect(
        Math.min(startPoint.x, currentPoint.x),
        Math.min(startPoint.y, currentPoint.y),
        Math.abs(currentPoint.x - startPoint.x),
        Math.abs(currentPoint.y - startPoint.y)
      );
      break;

    case Mode.drawCircle:
      const dx = currentPoint.x - startPoint.x;
      const dy = currentPoint.y - startPoint.y;
      const radius = Math.sqrt(dx * dx + dy * dy);
      ctx.arc(startPoint.x, startPoint.y, radius, 0, Math.PI * 2);
      break;

    default:
      ctx.setLineDash([]);
      return;
  }

  ctx.stroke();
  ctx.setLineDash([]);
}

// File: src/components/Canvas/utils/generateTimeTicks.ts
import { Tick } from "../../../types/Graph.ts";

type TimeDetailLevel = 'auto' | 'low' | 'medium' | 'high';

export function generateTimeTicks(
    startTime: number,
    endTime: number,
    canvasWidth: number,
    timeDetailLevel: TimeDetailLevel,
    timeFormat12h: boolean,
    minPixelPerTick = 60,
): Tick[] {
    const ticks: Tick[] = [];
    const rangeMs = endTime - startTime;

    // Calculate time span in days
    const timeSpanDays = rangeMs / (24 * 60 * 60 * 1000);

    // Determine appropriate tick interval based on time span
    let interval: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second';
    let intervalStep = 1;

    if (timeSpanDays > 365 * 2) {
        interval = 'year';
        intervalStep = Math.ceil(timeSpanDays / 365 / 10); // Show approximately 10 years
    } else if (timeSpanDays > 60) {
        interval = 'month';
        intervalStep = Math.ceil(timeSpanDays / 30 / 12); // Show approximately 12 months
    } else if (timeSpanDays > 10) {
        interval = 'day';
        intervalStep = Math.ceil(timeSpanDays / 10); // Show approximately 10 days
    } else if (timeSpanDays > 1) {
        interval = 'hour';
        intervalStep = Math.ceil(timeSpanDays * 24 / 12); // Show approximately 12 hours
    } else if (timeSpanDays > 0.04) { // ~1 hour
        interval = 'minute';
        intervalStep = Math.ceil(timeSpanDays * 24 * 60 / 15); // Show approximately every 15 minutes
    } else {
        interval = 'second';
        intervalStep = Math.ceil(timeSpanDays * 24 * 60 * 60 / 15); // Show approximately every 15 seconds
    }

    // Override with user-selected detail level if not auto
    if (timeDetailLevel !== 'auto') {
        switch (timeDetailLevel) {
            case 'low':
                if (interval === 'year') intervalStep = Math.max(intervalStep, 2);
                else if (interval === 'month') interval = 'year';
                else if (interval === 'day') interval = 'month';
                else if (interval === 'hour') interval = 'day';
                else if (interval === 'minute') interval = 'hour';
                else interval = 'minute';
                break;
            case 'medium':
                // Keep default interval but maybe adjust step
                break;
            case 'high':
                if (interval === 'year') interval = 'month';
                else if (interval === 'month') interval = 'day';
                else if (interval === 'day') interval = 'hour';
                else if (interval === 'hour') interval = 'minute';
                else if (interval === 'minute') interval = 'second';
                intervalStep = 1;
                break;
        }
    }

    // Calculate max ticks based on canvas width
    const maxTicks = Math.floor(canvasWidth / minPixelPerTick);

    // Generate ticks based on interval
    const startDate = new Date(startTime);
    const endDate = new Date(endTime);

    // Function to get next tick date based on interval
    function getNextTickDate(date: Date): Date {
        const newDate = new Date(date);
        switch (interval) {
            case 'year':
                newDate.setFullYear(newDate.getFullYear() + intervalStep);
                break;
            case 'month':
                newDate.setMonth(newDate.getMonth() + intervalStep);
                break;
            case 'day':
                newDate.setDate(newDate.getDate() + intervalStep);
                break;
            case 'hour':
                newDate.setHours(newDate.getHours() + intervalStep);
                break;
            case 'minute':
                newDate.setMinutes(newDate.getMinutes() + intervalStep);
                break;
            case 'second':
                newDate.setSeconds(newDate.getSeconds() + intervalStep);
                break;
        }
        return newDate;
    }

    // Function to format date based on interval
    function formatTickLabel(date: Date): string {
        switch (interval) {
            case 'year':
                return date.getFullYear().toString();
            case 'month':
                return date.toLocaleString('default', { month: 'short', year: 'numeric' });
            case 'day':
                return date.toLocaleString('default', { day: '2-digit', month: 'short' });
            case 'hour':
                return date.toLocaleString('default', { hour12: timeFormat12h, hour: '2-digit', minute: '2-digit' });
            case 'minute':
                return date.toLocaleString('default', { hour12: timeFormat12h, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            case 'second':
                return date.toLocaleString('default', { hour12: timeFormat12h, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }
    }
    
    // Find first tick (align to interval boundary)
    let currentDate = new Date(startDate);
    switch (interval) {
        case 'year':
            currentDate = new Date(currentDate.getFullYear(), 0, 1);
            break;
        case 'month':
            currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
            break;
        case 'day':
            currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
            break;
        case 'hour':
            currentDate = new Date(
                currentDate.getFullYear(), 
                currentDate.getMonth(), 
                currentDate.getDate(), 
                currentDate.getHours()
            );
            break;
        case 'minute':
            currentDate = new Date(
                currentDate.getFullYear(), 
                currentDate.getMonth(), 
                currentDate.getDate(), 
                currentDate.getHours(),
                Math.floor(currentDate.getMinutes() / intervalStep) * intervalStep
            );
            break;
        case 'second':
            currentDate = new Date(
                currentDate.getFullYear(), 
                currentDate.getMonth(), 
                currentDate.getDate(), 
                currentDate.getHours(),
                currentDate.getMinutes(),
                Math.floor(currentDate.getSeconds() / intervalStep) * intervalStep
            );
            break;
    }
    
    // If first tick is before start time, move to next tick
    if (currentDate.getTime() < startTime) {
        currentDate = getNextTickDate(currentDate);
    }
    
    // Generate ticks until we reach end time
    while (currentDate.getTime() <= endTime) {
        const tickTime = currentDate.getTime();
        const label = formatTickLabel(currentDate);
        
        ticks.push({ time: tickTime, label });
        currentDate = getNextTickDate(currentDate);
        
        // Safety check to prevent infinite loops
        if (ticks.length > 100) break;
    }
    
    // Ensure we don't have too many ticks for the available width
    if (ticks.length > maxTicks) {
        // Sample ticks evenly
        const step = Math.ceil(ticks.length / maxTicks);
        return ticks.filter((_, i) => i % step === 0);
    }
    
    return ticks;
}


// File: src/components/Drawing/Angleshape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface AngleShapeArgs {
    x0: number,
    y0: number,
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    color?: string,
    lineWidth?: number
}


export class AngleShape implements IDrawingShape {

    constructor(
        public x0: number,
        public y0: number,
        public x1: number,
        public y1: number,
        public x2: number,
        public y2: number,
        public color: string = 'teal',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {

        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.x0, this.y0);
        ctx.lineTo(this.x1, this.y1);
        ctx.moveTo(this.x0, this.y0);
        ctx.lineTo(this.x2, this.y2);
        ctx.stroke();
        const angleDeg = this.calculateAngle();
    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        return this.isPointNearLine(x, y, this.x0, this.y0, this.x1, this.y1, tolerance) ||
            this.isPointNearLine(x, y, this.x0, this.y0, this.x2, this.y2, tolerance);
    }

    private isPointNearLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, tolerance: number): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }

    private calculateAngle(): number {
        const v1 = {x: this.x1 - this.x0, y: this.y1 - this.y0};
        const v2 = {x: this.x2 - this.x0, y: this.y2 - this.y0};
        const dot = v1.x * v2.x + v1.y * v2.y;
        const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
        const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
        const cos = dot / (mag1 * mag2);
        return Math.acos(cos) * (100 / Math.PI);
    }
}

// File: src/components/Drawing/ArrowShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface ArrowShapeArgs {
    fromX: number,
    fromY: number,
    toX: number,
    toY: number,
    color?: string,
    lineWidth?: number
}

export class ArrowShape implements IDrawingShape {

    constructor(
        public fromX: number,
        public fromY: number,
        public toX: number,
        public toY: number,
        public color: string = 'black',
        public lineWidth: number = 2
    ) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        const headLength = 10;
        const dx = this.toX - this.fromX;
        const dy = this.toY - this.fromY;
        const angle = Math.atan2(dy, dx);

        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.fromX, this.fromY);
        ctx.lineTo(this.toX, this.toY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(this.toX, this.toY);
        ctx.lineTo(this.toX - headLength * Math.cos(angle - Math.PI / 6), this.toY - headLength * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(this.toX - headLength * Math.cos(angle + Math.PI / 6), this.toY - headLength * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(this.toX, this.toY);
        ctx.fillStyle = this.color;
        ctx.fill();

    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        return this.isPointNearLine(x, y, this.fromX, this.fromY, this.toX, this.toY, tolerance);
    }

    private isPointNearLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, tolerance: number): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }

}

// File: src/components/Drawing/CircleShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface CircleShapeArgs {
    centerX: number,
    centerY: number,
    radius: number,
    color?: string,
    lineWidth?: number
}

export class CircleShape implements IDrawingShape {
    constructor(
        public centerX: number,
        public centerY: number,
        public radius: number,
        public color: string = 'black',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.arc(this.centerX, this.centerY, this.radius, 0, Math.PI * 2);
    }

    isHit(x: number, y: number): boolean {
        const dx = x - this.centerX;
        const dy = y - this.centerY;
        return Math.sqrt(dx * dx + dy * dy) <= this.radius + this.lineWidth / 2;
    }
}

// File: src/components/Drawing/CustomSymbolShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface CustomSymbolShapeArgs {
    x: number,
    y: number,
    symbol: string,
    size: number,
    color: string
}

export class CustomSymbolShape implements IDrawingShape {

    constructor(
        public x: number,
        public y: number,
        public symbol: string = '*',
        public size: number = 24,
        public color: string = 'black') {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        ctx.fillStyle = this.color;
        ctx.font = `${this.size}px Arial`;
        ctx.fillText(this.symbol, this.x, this.y);
    }

    isHit(x: number, y: number): boolean {
        const halfSize = this.size / 2;
        return (
            x >= this.x - halfSize &&
            x <= this.x + halfSize &&
            y >= this.y - halfSize &&
            y <= this.y + halfSize
        );
    }

}

// File: src/components/Drawing/IDrawingShape.ts
export interface IDrawingShape {
    draw(ctx: CanvasRenderingContext2D): void;
    isHit(x: number, y: number): boolean;
}

// File: src/components/Drawing/LineShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface LineShapeArgs {
    startX: number,
    startY: number,
    endX: number,
    endY: number,
    color?: string,
    lineWidth?: number
}

export class LineShape implements IDrawingShape {
    constructor(
        public startX: number,
        public startY: number,
        public endX: number,
        public endY: number,
        public color: string = 'black',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.startX, this.startY);
        ctx.lineTo(this.endX, this.endY);
        ctx.stroke();
    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        return this.isPointNearLine(x, y, this.startX, this.startY, this.endX, this.endY, tolerance);
    }

    private isPointNearLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, tolerance: number): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }
}

// File: src/components/Drawing/Polyline.ts
import {IDrawingShape} from "./IDrawingShape.ts";

interface Point {
    x: number,
    y: number
}

export interface PolylineShapeArgs {
    points: Point[],
    color?: string,
    lineWidth?: number
}


export class Polyline implements IDrawingShape {

    constructor(
        public points: Point[],
        public color: string = 'navy',
        public lineWidth: number = 2
    ) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        if (this.points?.length < 2) return;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.points[0].x, this.points[0].y);
        this.points.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
        ctx.stroke();
    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        for (let i = 0; i < this.points.length - 1; i++) {
            const p1 = this.points[i];
            const p2 = this.points[i + 1];
            if (this.isPointNearLine(x, y, p1.x, p1.y, p2.x, p2.y, tolerance)) {
                return true;
            }
        }
        return false;
    }

    private isPointNearLine(
        px: number, py: number,
        x1: number, y1: number,
        x2: number, y2: number,
        tolerance: number
    ): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }
}

// File: src/components/Drawing/RectangleShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface RectangleShapeArgs {
    x: number,
    y: number,
    width: number,
    height: number,
    color?: string,
    lineWidth?: number
}


export class RectangleShape implements IDrawingShape {
    constructor(
        public x: number,
        public y: number,
        public width: number,
        public height: number,
        public color: string = 'blue',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.strokeRect(this.x, this.y, this.width, this.height);
    }

    isHit(x: number, y: number): boolean {
        return (
            x >= this.x &&
            x <= this.x + this.width &&
            y >= this.y &&
            y <= this.y + this.height
        );
    }
}

// File: src/components/Drawing/TriangleShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface TriangleShapeArgs {
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    x3: number,
    y3: number,
    color?: string,
    lineWidth?: number
}


export class TriangleShape implements IDrawingShape {

    constructor(
        public x1: number,
        public y1: number,
        public x2: number,
        public y2: number,
        public x3: number,
        public y3: number,
        public color: string = 'black',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {

        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.x1, this.y1);
        ctx.lineTo(this.x2, this.y2);
        ctx.lineTo(this.x3, this.y3);
        ctx.closePath();
        ctx.stroke();
    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        return (
            this.isPointNearLine(x, y, this.x1, this.y1, this.x2, this.y2, tolerance) ||
            this.isPointNearLine(x, y, this.x2, this.y2, this.x3, this.y3, tolerance) ||
            this.isPointNearLine(x, y, this.x3, this.y3, this.x1, this.y1, tolerance)
        );
    }

    private isPointNearLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, tolerance: number): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }
}

// File: src/components/Drawing/types.ts
import {Mode} from "../../contexts/ModeContext.tsx";

export type Drawing = {
    mode: Mode;
    args: any; // 转 祝 -type 拽 转专  砖
}

// File: src/components/Toolbar/ModeButton.tsx


import React from 'react';
import { Mode } from '../../contexts/ModeContext';

interface ModeButtonProps {
  mode: Mode;
  currentMode: Mode;
  onClick: (mode: Mode) => void;
  label: string;
}

const ModeButton: React.FC<ModeButtonProps> = ({ mode, currentMode, onClick, label }) => {
  const selected = mode === currentMode;
  return (
    <button
      className={selected ? 'selected' : ''}
      onClick={() => onClick(mode)}
    >
      {label}
    </button>
  );
};

export default ModeButton;

// File: src/components/Toolbar/SettingsToolbar.tsx
import React from 'react';
import '../../styles/SettingsToolbar.scss';
export const SettingsToolbar: React.FC = () => {
    const handleDownload = () => {
        const canvas = document.querySelector('Canvas');
        if (!canvas) return;
        const link = document.createElement('a');
        link.download = 'chart-snapshot.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
    };

    return (
        <div className={'settings-toolbar'}>
            <input type="text" placeholder="Symbol"/>
            <select>
                <option value="1m">1 Min</option>
                <option value="5m">5 Min</option>
                <option value="1h">1 Hour</option>
                <option value="1d">1 Day</option>
            </select>
            <select>
                <option value="50">50 Bars</option>
                <option value="100">100 Bars</option>
                <option value="200">200 Bars</option>
            </select>
            <select>
                <option value="candlestick">Candlestick</option>
                <option value="line">Line</option>
            </select>
            <button onClick={handleDownload}> Snapshot</button>
            <button>锔 Settings</button>
        </div>
    );
};

// File: src/components/Toolbar/Toolbar.tsx
import React from 'react';
import { Mode, useMode } from '../../contexts/ModeContext';
import ModeButton from './ModeButton';
import '../../styles/Toolbar.scss';

export const Toolbar: React.FC = () => {
  const { mode, setMode } = useMode();

  return (
    <div className={'toolbar-container'}>
      <div className={'toolbar'}>
        <ModeButton mode={Mode.drawLine} currentMode={mode} onClick={setMode} label="D Line" />
        <ModeButton mode={Mode.drawRectangle} currentMode={mode} onClick={setMode} label="D Rect" />
        <ModeButton mode={Mode.drawCircle} currentMode={mode} onClick={setMode} label="D Cir" />
        <ModeButton mode={Mode.drawTriangle} currentMode={mode} onClick={setMode} label="D Triangle" />
        <ModeButton mode={Mode.drawAngle} currentMode={mode} onClick={setMode} label="D Angle" />
        <ModeButton mode={Mode.select} currentMode={mode} onClick={setMode} label="Select" />
        <ModeButton mode={Mode.editShape} currentMode={mode} onClick={setMode} label="Edit" />
      </div>
    </div>
  );
};

// File: src/contexts/ModeContext.tsx
import React, {createContext, useContext, useState} from 'react';

export enum Mode {
    none,
    drawLine,
    drawRectangle,
    drawCircle,
    drawTriangle,
    drawAngle,
    select,
    editShape,
    drawPolyline,
    drawArrow,
    drawCustomSymbol,
    drawText
}

interface ModeContextProps {
    mode: Mode;
    setMode: (mode: Mode) => void;
}

const ModeContext = createContext<ModeContextProps | undefined>(undefined);

export const ModeProvider: React.FC<{ children: React.ReactNode }> = ({children}) => {
    const [mode, setModeState] = useState<Mode>(Mode.none);

    const setMode = (newMode: Mode) => {
        setModeState(prev => (prev === newMode ? Mode.none : newMode));
    };

    return (
        <ModeContext.Provider value={{mode, setMode}}>
            {children}
        </ModeContext.Provider>
    );
};

export const useMode = (): ModeContextProps => {
    const context = useContext(ModeContext);
    if (!context) {
        throw new Error('useMode must be used within a ModeProvider');
    }
    return context;
};

// File: src/index.css
@tailwind base;
@tailwind components;
@tailwind utilities;

// File: src/main.ts


// File: src/main.tsx
import './index.css'; //

import React from 'react';
import ReactDOM from 'react-dom/client';
import {App} from './components/App';
import {ModeProvider} from './contexts/ModeContext';

const root = document.getElementById('root') as HTMLElement;

ReactDOM.createRoot(root).render(
    <React.StrictMode>
        <ModeProvider>
            <App/>
        </ModeProvider>
    </React.StrictMode>
);

// File: src/store/useChartStore.ts
import {create} from 'zustand';
import type {Candle} from '../types/Candle.ts';
import {} from '../types/Candle.ts'
import {TimeRange} from '../types/Graph.ts';
import {useState} from "react";


interface ChartState {
    numberOfXTicks: number;
    numberOfYTicks: number;
    timeFormat: string;
    timeFormat12h: boolean;
    xAxisHeight: number;
    yAxisWidth: number;
    setXAxisHeight: (height: number) => void;
    setYAxisWidth: (width: number) => void;
    setCanvasWidth: (width: number) => void;
    setCanvasHeight: (height: number) => void;
    setNumberOfXTicks: (n: number) => void;
    setNumberOfYTicks: (n: number) => void;
    setTimeFormat: (format: string) => void;
    setTimeFormat12h: (value: boolean) => void;
    setVisibleRange: (range: { start: number; end: number }) => void;

    // Drawing state
    drawings: any[]; // 驻砖专 祝 住 拽 转专
    setDrawings: (drawings: any[] | ((prev: any[]) => any[])) => void;
    selectedIndex: number | null;
    setSelectedIndex: (index: number | null) => void;

    // Mode
    mode: string;
    setMode: (mode: string) => void;

    // Is Drawing
    isDrawing: boolean;
    setIsDrawing: (val: boolean) => void;

    // Points
    startPoint: { x: number; y: number } | null;
    setStartPoint: (point: { x: number; y: number } | null) => void;
    currentPoint: { x: number; y: number } | null;
    setCurrentPoint: (point: { x: number; y: number } | null) => void;

    stepX: number;
    stepY: number;
    strokeStyle: string;
    padding: number;

    setStepX: (value: number) => void;
    setStepY: (value: number) => void;
    setStrokeStyle: (value: string) => void;
    setPadding: (value: number) => void;

    minPrice: number;
    maxPrice: number;
    setMinPrice: (value: number) => void;
    setMaxPrice: (value: number) => void;

    yAxisPosition: 'left' | 'right';
    setYAxisPosition: (position: 'left' | 'right') => void;

    priceDecimalPlaces: number;
    setPriceDecimalPlaces: (value: number) => void;

    decimalSeparator: string;
    setDecimalSeparator: (value: string) => void;

    thousandSeparator: string;
    setThousandSeparator: (value: string) => void;

    currencySymbol: string;
    setCurrencySymbol: (value: string) => void;

    currencySymbolPosition: 'before' | 'after';
    setCurrencySymbolPosition: (value: 'before' | 'after') => void;

    safeCandles: Candle[];
    visibleCandles: Candle[];
    candlesToUse: Candle[];
    visibleRange: TimeRange;

    setCandlesAndVisibleRange: (candles: Candle[], visibleRange: TimeRange) => void;

    timeDetailLevel: 'auto' | 'low' | 'medium' | 'high';
    setTimeDetailLevel: (level: 'auto' | 'low' | 'medium' | 'high') => void;
}

export const useChartStore = create<ChartState>((set) => ({
    numberOfXTicks: 5,
    numberOfYTicks: 5,
    timeFormat: 'YYYY/MM/DD',
    timeFormat12h: false, // false = 24 砖注转, true = 12 砖注转 AM/PM
    xAxisHeight: 40,
    yAxisWidth: 40,
    setXAxisHeight: (height) => set({xAxisHeight: height}),
    setYAxisWidth: (width) => set({yAxisWidth: width}),
    stepX: 50,
    stepY: 50,
    strokeStyle: '#eee',
    padding: 15,
    setCandles: (candles) => set({candles}),
    candles: [],
    visibleRange: {start: Date.now() - 365 * 24 * 60 * 60 * 1000, end: Date.now()},
    setVisibleRange: (range) => set({visibleRange: range}),
    setCanvasWidth: (width) => set({canvasWidth: width}),
    setCanvasHeight: (height) => set({canvasHeight: height}),
    setNumberOfXTicks: (n) => set({numberOfXTicks: n}),
    setNumberOfYTicks: (n) => set({numberOfYTicks: n}),
    setTimeFormat: (format) => set({timeFormat: format}),
    setTimeFormat12h: (value) => set({timeFormat12h: value}),

    drawings: [],
    setDrawings: (update) => set(state => ({
        drawings: typeof update === 'function' ? update(state.drawings) : update
    })),
    selectedIndex: null,
    setSelectedIndex: (index) => set({selectedIndex: index}),

    mode: 'none',
    setMode: (mode) => set({mode}),

    isDrawing: false,
    setIsDrawing: (val) => set({isDrawing: val}),

    startPoint: null,
    setStartPoint: (point) => set({startPoint: point}),

    currentPoint: null,
    setCurrentPoint: (point) => set({currentPoint: point}),

    setStepX: (value) => set({stepX: value}),
    setStepY: (value) => set({stepY: value}),
    setStrokeStyle: (value) => set({strokeStyle: value}),
    setPadding: (value) => set({padding: value}),

    minPrice: 0,
    maxPrice: 100,
    setMinPrice: (value) => set({minPrice: value}),
    setMaxPrice: (value) => set({maxPrice: value}),

    yAxisPosition: 'left',
    setYAxisPosition: (position) => set({yAxisPosition: position}),

    priceDecimalPlaces: 2,
    setPriceDecimalPlaces: (value) => set({priceDecimalPlaces: value}),

    decimalSeparator: '.',
    setDecimalSeparator: (value) => set({decimalSeparator: value}),

    thousandSeparator: ',',
    setThousandSeparator: (value) => set({thousandSeparator: value}),

    currencySymbol: '$',
    setCurrencySymbol: (value) => set({currencySymbol: value}),

    currencySymbolPosition: 'before',
    setCurrencySymbolPosition: (value) => set({currencySymbolPosition: value}),

    safeCandles: [],
    visibleCandles: [],
    candlesToUse: [],
    setCandlesAndVisibleRange: (candles, visibleRange) => set(state => {
        const safeCandles = candles || [];
        const visibleCandles = safeCandles.filter(
            c => visibleRange && c.t >= visibleRange.start && c.t <= visibleRange.end
        );
        const candlesToUse = visibleCandles.length > 0 ? visibleCandles : safeCandles;
        const prices = candlesToUse.length > 0
            ? candlesToUse.flatMap(c => [c.h, c.l])
            : [];
        const maxPrice = prices.length > 0 ? Math.max(...prices) : 1;
        const minPrice = prices.length > 0 ? Math.min(...prices) : 0;
        return {
            safeCandles,
            visibleRange,
            visibleCandles,
            candlesToUse,
            minPrice,
            maxPrice
        };
    }),

    timeDetailLevel: 'auto',
    setTimeDetailLevel: (level) => set({timeDetailLevel: level}),
}));

// File: src/styles/App.scss
//make the html file to cover the whole screen
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
    overflow: hidden; /* 注  转专转 */
}

#root {
  height: calc(100% - 4px); /* 专  砖 -toolbar */
  width: calc(100% - 4px); /* 专 专 砖 -toolbar */
  margin: 2px;
  padding: 0;
  display: flex;
  flex-direction: column;
  overflow: hidden; /* 注  转专转 */
}

// make the app container to cover the whole screen
.main-app-window {
  display: flex;
  flex-direction: column;
  position: relative;
  height: 100%;
  width: 100%;
  padding: 2px;
  box-sizing: border-box;
  overflow: hidden; /* 注  转专转 */
}

.settings-area {
  display: flex;
  flex-direction: row;
  height: 30px;
  width: 100%;
}

.lower-container {
  height: calc(100% - 40px);
  width: 100%;
  display: flex;
  flex-direction: row;
  overflow: hidden; /* 注  驻拽转 */
}
.toolbar-container {
  width: 40px; /* 专 住专  */
  height: 100%;
  flex-shrink: 0; /* 注 抓 */
}

// File: src/styles/Canvas/Axes.scss


// File: src/styles/Canvas/CanvasStage.scss

//.canvas-container canvas {
//  position: absolute;
//  top: 0;
//  left: 0;
//  z-index: 0;
//}

// File: src/styles/Canvas/ChartCanves.scss
.chart-canvas-container {
  flex-grow: 1;
  width: calc(100% - 40px); /* 专 专 砖 -toolbar */
  height: 100%;
  position: relative;
  display: block;
  max-height: 100%;
}

// File: src/styles/Canvas/Grid.scss


// File: src/styles/Drawing.scss


// File: src/styles/Overlays.scss


// File: src/styles/SettingsToolbar.scss

.settings-toolbar {
  background: #ddd;
  display: flex;
  height: 100%;
  width: 100%;
  justify-content: start;
  align-content: center;
  align-items: center;

  input, select, button {
    height: 100%;
    border-radius: 3px;
    border-width: 1px;
    width: fit-content;
    font-size: 11px;
    padding: 0 5px;
  }

  input {
    height: calc(100% - 2px);
    width: 100px;
  }

}

// File: src/styles/Toolbar.scss
@use '../styles/variables' as v;

.toolbar-container {
  display: flex;
  flex-grow: 0;
  flex-shrink: 0;
  width: v.$toolbar-width;
  background-color: #ddd;
  height: 100%;
}

.toolbar {
  width: v.$toolbar-width;
  height: 100%;
  display: grid;
  grid-column: 1;
  grid-auto-flow: row;
  grid-template-rows: auto;
  grid-template-columns: auto;
  align-content: start;

  button {
    display: flex;
    min-height: v.$toolbar-width;
    width: 100%;
    flex-grow: 1;
    padding: 0;
    overflow: hidden;
    text-align: center;
    font-size: 10px;

    &.selected {
      background-color: #333;
      color: #fff;
      border-left: 3px solid #007bff;
    }
  }
}

// File: src/styles/_variables.scss

$toolbar-width: 40px;

// File: src/types/Candle.ts
// 驻住 Candle 注 砖转 t, o, c, l, h
export interface Candle {
    t: number; // timestamp
    o: number; // open
    c: number; // close
    l: number; // low
    h: number; // high
}

export interface CandleWithIndex extends Candle {
    index: number; // index in the original array
}

// File: src/types/Graph.ts
export interface Tick {
    time: number;      // timestamp UNIX 砖转
    label: string;     // 转爪转 拽 拽住
}

export interface TimeRange {
    start: number; // timestamp 转
    end: number;   // timestamp 住
}

// File: src/types/chartStyleOptions.d.ts
// chartStyleOptions.ts

// Candles style
import {AxesPosition} from "./types.ts";

export interface CandleStyleOptions {
    upColor?: string;
    downColor?: string;
    borderColor?: string;
    borderWidth?: number;
    bodyWidthFactor?: number;
    spacingFactor?: number;
}

// Grid style
export interface GridStyleOptions {
    gridSpacing?: number;
    lineColor?: string;
    lineWidth?: number;
    lineDash?: number[];
}

// Axes style
export interface AxesStyleOptions {
    axisPosition?: AxesPosition;
    textColor?: string;
    font?: string;
    lineColor?: string;
    lineWidth?: number;
    numberLocale?: string;
    dateLocale?: string;
    numberFractionDigits?: number; // Number of decimal places to format axis values
}
export interface LineOverlayOptions{
    color?: string;
    lineWidth?: number;
    dashed?: boolean;
}
// Main Chart style options
export interface ChartStyleOptions {
    candles?: CandleStyleOptions;
    grid?: GridStyleOptions;
    axes?: AxesStyleOptions;
    lineOverlay?:LineOverlayOptions;
    backgroundColor?:string;
    // 驻砖专 住祝 驻 注 (砖 lineOverlay ')
}

// File: src/types/types.ts
import {ChartStyleOptions} from "./chartStyleOptions";

// Enum for Axis position
export enum AxesPosition {
    left = 'left',
    right = 'right',
}

// Base chart options
interface BaseChartOptions {
    theme?: 'light' | 'dark' | 'grey' | string;
    showOverlayLine?: boolean;
    style?: Partial<ChartStyleOptions>;
}

// Line chart data point
export interface LineData {
    time: number;
    value: number;
}

// Candlestick chart data point (full)
export interface CandleData {
    time: number;
    open: number;
    high: number;
    low: number;
    close: number;
}

// Candlestick chart data point (compact)
export interface CandleDataCompact {
    t: number;
    o: number;
    h: number;
    l: number;
    c: number;
}

// Line chart options
export interface LineChartOptions extends BaseChartOptions {
    type: 'line';
    data: LineData[];
}

// Candlestick chart options
export interface CandleChartOptions extends BaseChartOptions {
    type: 'candlestick';
    data: (CandleData | CandleDataCompact)[];
}

// Unified ChartOptions type
export type ChartOptions = LineChartOptions | CandleChartOptions;

// File: src/vite-env.d.ts
/// <reference types="vite/client" />


