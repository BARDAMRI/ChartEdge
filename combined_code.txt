// File: src/components/App.tsx
import React from 'react';
import {ChartCanvas} from './Canvas/ChartCanvas.tsx';
import {Toolbar} from './Toolbar/Toolbar.tsx';
import {SettingsToolbar} from './Toolbar/SettingsToolbar.tsx';
import '../styles/App.scss';

export const App: React.FC = () => {
    return (
        <div className={'main-app-window'}>
            <div className={'settings-area'}>
                <SettingsToolbar/>
            </div>
            <div className={'lower-container'}>
                <ChartCanvas/>
                <Toolbar/>
            </div>
        </div>
    );
};

// File: src/components/Canvas/ChartCanvas.tsx
import React, {useRef, useEffect} from 'react';
import {Mode, useMode} from '../../contexts/ModeContext';
import {Candle, TimeRange} from '../../types/Candle';
import {drawGrid} from './utils/drawGrid';
import {drawAxes} from './utils/drawAxes';
import {drawCandlesticks} from './utils/drawCandlesticks';
import {drawDrawings} from './utils/drawDrawings';
import {drawOverlay} from './utils/drawOverlay';
import {useChartStore} from '../../store/useChartStore';

interface ChartCanvasProps {
    candles: Candle[];
    visibleRange?: TimeRange | null;
}

export const ChartCanvas: React.FC<ChartCanvasProps> = ({
                                                            candles,
                                                            visibleRange: initialVisibleRange,
                                                        }) => {
    const mode = useMode().mode;
    const isDrawing = useChartStore(state => state.isDrawing);
    const setIsDrawing = useChartStore(state => state.setIsDrawing);
    const startPoint = useChartStore(state => state.startPoint);
    const setStartPoint = useChartStore(state => state.setStartPoint);
    const currentPoint = useChartStore(state => state.currentPoint);
    const setCurrentPoint = useChartStore(state => state.setCurrentPoint);
    const drawings = useChartStore(state => state.drawings);
    const setDrawings = useChartStore(state => state.setDrawings);
    const selectedIndex = useChartStore(state => state.selectedIndex);
    const setSelectedIndex = useChartStore(state => state.setSelectedIndex);
    const visibleRange = useChartStore(state => state.visibleRange);
    const setVisibleRange = useChartStore(state => state.setVisibleRange);
    const canvasWidth = useChartStore(state => state.canvasWidth);
    const setCanvasWidth = useChartStore(state => state.setCanvasWidth);
    const canvasHeight = useChartStore(state => state.canvasHeight);
    const setCanvasHeight = useChartStore(state => state.setCanvasHeight);

    const containerRef = useRef<HTMLDivElement | null>(null);
    const canvasRef = useRef<HTMLCanvasElement | null>(null);

    const padding = useChartStore(state => state.padding);

    const candlesToUse = useChartStore(state => state.candlesToUse);
    const minPrice = useChartStore(state => state.minPrice);
    const maxPrice = useChartStore(state => state.maxPrice);
    const setCandlesAndVisibleRange = useChartStore(state => state.setCandlesAndVisibleRange);

    useEffect(() => {
        if (!containerRef.current) return;
        const container = containerRef.current!;
        const observer = new ResizeObserver(entries => {
            for (const entry of entries) {
                setCanvasWidth(entry.contentRect.width);
                setCanvasHeight(entry.contentRect.height);
            }
        });
        observer.observe(container);
        return () => {
            observer.disconnect();
        };
    }, []);

    const now = Date.now();
    const oneYearAgo = now - 365 * 24 * 60 * 60 * 1000;
    const defaultVisibleRange: TimeRange = {
        start: oneYearAgo,
        end: now,
    };

    // Initialize visibleRange in store if not set and initialVisibleRange is provided
    useEffect(() => {
        if (initialVisibleRange && candles && candles.length && !visibleRange) {
            setVisibleRange(initialVisibleRange);
        } else if (!visibleRange) {
            setVisibleRange(defaultVisibleRange);
        }
    }, [initialVisibleRange, candles, visibleRange, setVisibleRange]);

    // useEffect for setting candles and visible range in store
    useEffect(() => {
        setCandlesAndVisibleRange(candles, visibleRange || { start: 0, end: Date.now() });
    }, [candles, visibleRange, setCandlesAndVisibleRange]);

    const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
        if (!canvasRef.current) return;
        const rect = canvasRef.current!.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        if (mode === Mode.select) {
            for (let i = 0; i < drawings.length; i++) {
                const d = drawings[i];
                let shape = null;
                if (d.mode === Mode.drawLine) {
                    // @ts-ignore
                    shape = new LineShape(d.args.startX, d.args.startY, d.args.endX, d.args.endY);
                } else if (d.mode === Mode.drawRectangle) {
                    // @ts-ignore
                    shape = new RectangleShape(d.args.x, d.args.y, d.args.width, d.args.height);
                } else if (d.mode === Mode.drawCircle) {
                    // @ts-ignore
                    shape = new CircleShape(d.args.centerX, d.args.centerY, d.args.radius);
                }
                if (shape && shape.isHit(x, y)) {
                    setSelectedIndex(i);
                    return;
                }
            }
            setSelectedIndex(null);
            return;
        }

        if (mode !== Mode.none) {
            setStartPoint({x, y});
            setIsDrawing(true);
        }
    };

    const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
        if (!isDrawing || !startPoint || mode === Mode.none) return;
        if (!canvasRef.current) return;

        const rect = canvasRef.current!.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        setCurrentPoint({x, y});
    };

    const handleMouseUp = (e: React.MouseEvent<HTMLCanvasElement>) => {
        if (!isDrawing || !startPoint || mode === Mode.none) return;
        if (!canvasRef.current) return;

        const rect = canvasRef.current!.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        setDrawings(prev => {
            const newDrawing = {
                [Mode.drawLine]: () => ({
                    mode: Mode.drawLine,
                    args: {
                        startX: startPoint.x,
                        startY: startPoint.y,
                        endX: x,
                        endY: y,
                    },
                }),
                [Mode.drawRectangle]: () => ({
                    mode: Mode.drawRectangle,
                    args: {
                        x: startPoint.x,
                        y: startPoint.y,
                        width: x - startPoint.x,
                        height: y - startPoint.y,
                    },
                }),
                [Mode.drawCircle]: () => {
                    const dx = x - startPoint.x;
                    const dy = y - startPoint.y;
                    const radius = Math.sqrt(dx * dx + dy * dy);
                    return {
                        mode: Mode.drawCircle,
                        args: {
                            centerX: startPoint.x,
                            centerY: startPoint.y,
                            radius,
                        },
                    };
                }
            }[mode];

            return newDrawing ? [...prev, newDrawing()] : prev;
        });
        setIsDrawing(false);
        setStartPoint(null);
        setCurrentPoint(null);
    };

    function formatUnixTime(unixTime: number): string {
        const date = new Date(unixTime);
        const options: Intl.DateTimeFormatOptions = {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
        };
        return new Intl.DateTimeFormat('he-IL', options).format(date);
    }

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        if (canvasWidth === 0 || canvasHeight === 0) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvasWidth * dpr;
        canvas.height = canvasHeight * dpr;
        canvas.style.width = `${canvasWidth}px`;
        canvas.style.height = `${canvasHeight}px`;

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);

        ctx.clearRect(0, 0, canvas.width, canvasHeight);

        drawGrid(ctx, canvas.width, canvasHeight, padding);
        drawAxes(
            ctx,
            candlesToUse,
            canvas.width,
            canvasHeight,
            padding
        );
        drawCandlesticks(ctx, candlesToUse, visibleRange, padding, minPrice, maxPrice);
        drawDrawings(ctx, drawings, selectedIndex);
        drawOverlay(ctx, mode, isDrawing, startPoint, currentPoint);

    }, [
        candlesToUse,
        visibleRange,
        drawings,
        selectedIndex,
        mode,
        isDrawing,
        startPoint,
        currentPoint,
        canvasHeight,
        canvasWidth,
        padding,
        minPrice,
        maxPrice,
    ]);

    return (
        <div ref={containerRef} className="chart-canvas-container" style={{width: '100%', height: '100%'}}>
            <canvas
                ref={canvasRef}
                style={{width: '100%', height: '100%', userSelect: 'none', display: 'block'}}
                onMouseDown={handleMouseDown}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
            />
        </div>
    );
};

// File: src/components/Canvas/utils/drawAxes.ts
import {Candle} from "../../../types/Candle.ts";
import { useChartStore } from '../../../store/useChartStore';

export function drawAxes(
    ctx: CanvasRenderingContext2D,
    candles: Candle[],
    width: number,
    height: number,
    padding: number,
) {
    const {
      visibleRange,
      minPrice,
      maxPrice,
      yAxisPosition,
      numberOfYTicks,
      numberOfXTicks,
      timeFormat,
      priceDecimalPlaces,
    } = useChartStore.getState?.();

    function formatUnixTime(unixTime: number): string {
      const date = new Date(unixTime);
      const options: Intl.DateTimeFormatOptions = timeFormat;
      return new Intl.DateTimeFormat('default', options).format(date);
    }

    ctx.strokeStyle = '#333';
    ctx.fillStyle = '#333';
    ctx.lineWidth = 2;
    ctx.font = '12px Arial';
    ctx.textBaseline = 'middle';

    const yAxisX = yAxisPosition === 'left' ? padding : width - padding;

    // 爪专 拽 爪专 Y
    ctx.beginPath();
    ctx.moveTo(yAxisX, padding);
    ctx.lineTo(yAxisX, height - (padding - 7));
    ctx.stroke();

    ctx.textBaseline = 'top';
    ctx.textAlign = 'center';

    // 爪专 拽 爪专 X
    ctx.beginPath();
    ctx.moveTo(padding, height - padding);
    ctx.lineTo(width - padding, height - padding);
    ctx.stroke();

    // 爪专 注专  爪专 Y
    const step = (maxPrice - minPrice) / (numberOfYTicks - 1);

    for (let i = 0; i < numberOfYTicks; i++) {
        const value = minPrice + i * step;
        const y = height - padding - (i * (height - 2 * padding) / (numberOfYTicks - 1));

        const formattedValue = value.toFixed(priceDecimalPlaces);
        const offset = (formattedValue.length ) * 5;
        const xPos = yAxisPosition === 'left' ? yAxisX - offset : yAxisX + offset;

        ctx.fillText(formattedValue, xPos, y - 5);

        ctx.beginPath();
        ctx.moveTo(yAxisX - (yAxisPosition === 'left' ? 5 : -5), y);
        ctx.lineTo(yAxisX , y);
        ctx.stroke();

    }

    // 爪专 注专  爪专 X 注 砖砖 驻拽爪 formatUnixTime
    const timeRange = visibleRange.end - visibleRange.start;
    if (timeRange <= 0) return;

    ctx.textAlign = 'center';

    const xPositions = [
        visibleRange.start,
        visibleRange.end
    ];
    // 住驻转 注专 转 注  住驻专 ticks -x
    const stepX = (visibleRange.end - visibleRange.start) / (numberOfXTicks - 1);
    for (let i = 1; i < numberOfXTicks - 1; i++) {
        xPositions.push(visibleRange.start + i * stepX);
    }

    //  注专   住专 专
    xPositions.sort((a, b) => a - b);


    // 爪专 注专 爪专 X
    xPositions.forEach(time => {
        // 住驻转 拽 专 10 注 拽住
        const x = padding + ((time - visibleRange.start) / timeRange) * (width - 2 * padding);
        ctx.beginPath();
        ctx.moveTo(x, height - padding);
        ctx.lineTo(x, height - padding + 7);
        ctx.stroke();
        // 住驻转 拽住 转转 拽
        const label = formatUnixTime(time);
        ctx.fillText(label, x, height - padding + 10);
    });
}

// File: src/components/Canvas/utils/drawCandlesticks.ts
import {Candle} from '../../../types/Candle';
import {useChartStore} from "../../../store/useChartStore.ts";

export function drawCandlesticks(
    ctx: CanvasRenderingContext2D,
    candles: Candle[],
    visibleRange: { start: number; end: number },
    padding: number,
    minPrice: number,
    maxPrice: number
): void {

    const {canvasWidth, canvasHeight} = useChartStore.getState?.();

    const drawableWidth = canvasWidth - 2 * padding;
    const drawableHeight = canvasHeight - 2 * padding;

    const candleCount = visibleRange.end - visibleRange.start;
    if (candleCount <= 0) return;

    const candleSpacing = drawableWidth / candleCount;
    const candleWidth = candleSpacing * 0.6;

    const priceRange = maxPrice - minPrice;

    // 驻拽爪 专转 专 拽 Y 拽住
    const priceToY = (price: number) => {
        return padding + drawableHeight * (1 - (price - minPrice) / priceRange);
    };

    const visibleCandles = candles.slice(visibleRange.start, visibleRange.end);

    visibleCandles.forEach((candle, i) => {
        const x = padding + i * candleSpacing;
        const highY = priceToY(candle.h);
        const lowY = priceToY(candle.l);
        const openY = priceToY(candle.o);
        const closeY = priceToY(candle.c);

        const isUp = candle.c >= candle.o;

        ctx.strokeStyle = isUp ? 'green' : 'red';
        ctx.fillStyle = isUp ? 'green' : 'red';
        ctx.lineWidth = 1;

        // 爪专 -wick (拽 注 转转)
        ctx.beginPath();
        ctx.moveTo(x + candleWidth / 2, highY);
        ctx.lineTo(x + candleWidth / 2, lowY);
        ctx.stroke();

        // 爪专 祝 专
        const bodyY = Math.min(openY, closeY);
        const bodyHeight = Math.max(1, Math.abs(openY - closeY)); // 驻转 1 驻拽住 
        ctx.fillRect(x, bodyY, candleWidth, bodyHeight);
    });
}



// File: src/components/Canvas/utils/drawDrawings.ts


import { Drawing } from '../../Drawing/types';
import { LineShape } from '../../Drawing/LineShape';
import { RectangleShape } from '../../Drawing/RectangleShape';
import { CircleShape } from '../../Drawing/CircleShape';
import { TriangleShape } from '../../Drawing/TriangleShape';
import { AngleShape } from '../../Drawing/AngleShape';
import { Polyline } from '../../Drawing/Polyline';
import { ArrowShape } from '../../Drawing/ArrowShape';
import { CustomSymbolShape } from '../../Drawing/CustomSymbolShape';
import { Mode } from '../../../contexts/ModeContext';

export function drawDrawings(
  ctx: CanvasRenderingContext2D,
  drawings: Drawing[],
  selectedIndex: number | null
): void {
  drawings.forEach((d, index) => {
    ctx.beginPath();
    let shape = null;
    switch (d.mode) {
      case Mode.drawLine:
        shape = new LineShape(
          d.args.startX,
          d.args.startY,
          d.args.endX,
          d.args.endY
        );
        break;
      case Mode.drawRectangle:
        shape = new RectangleShape(
          d.args.x,
          d.args.y,
          d.args.width,
          d.args.height
        );
        break;
      case Mode.drawCircle:
        shape = new CircleShape(
          d.args.centerX,
          d.args.centerY,
          d.args.radius
        );
        break;
      case Mode.drawTriangle:
        shape = new TriangleShape(
          d.args.x1,
          d.args.y1,
          d.args.x2,
          d.args.y2,
          d.args.x3,
          d.args.y3
        );
        break;
      case Mode.drawAngle:
        shape = new AngleShape(
          d.args.x0,
          d.args.y0,
          d.args.x1,
          d.args.y1,
          d.args.x2,
          d.args.y2
        );
        break;
      case Mode.drawPolyline:
        shape = new Polyline(d.args.points);
        break;
      case Mode.drawArrow:
        shape = new ArrowShape(
          d.args.fromX,
          d.args.fromY,
          d.args.toX,
          d.args.toY
        );
        break;
      case Mode.drawCustomSymbol:
        shape = new CustomSymbolShape(
          d.args.x,
          d.args.y,
          d.args.symbol,
          d.args.size,
          d.args.color
        );
        break;
      default:
        break;
    }

    if (shape) {
      if (selectedIndex === index) {
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
      } else {
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
      }
      shape.draw(ctx);
      ctx.stroke();
    }
  });
}

// File: src/components/Canvas/utils/drawGrid.ts
import { useChartStore } from '../../../store/useChartStore';

export function drawGrid(
  ctx: CanvasRenderingContext2D,
  width: number,
  height: number,
  padding: number,
) {
  const { stepX, stepY, strokeStyle } = useChartStore.getState?.();

  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = 1;

  // 拽 
  for (let x = padding; x <= width - padding; x += stepX) {
    ctx.beginPath();
    ctx.moveTo(x, padding);
    ctx.lineTo(x, height - padding);
    ctx.stroke();
  }

  // 拽 驻拽
  for (let y = padding; y <= height - padding; y += stepY) {
    ctx.beginPath();
    ctx.moveTo(padding, y);
    ctx.lineTo(width - padding, y);
    ctx.stroke();
  }
}


// File: src/components/Canvas/utils/drawOverlay.ts


import { Mode } from '../../../contexts/ModeContext';

export function drawOverlay(
  ctx: CanvasRenderingContext2D,
  mode: Mode,
  isDrawing: boolean,
  startPoint: { x: number; y: number } | null,
  currentPoint: { x: number; y: number } | null
) {
  if (!isDrawing || !startPoint || !currentPoint) return;

  ctx.strokeStyle = 'blue';
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 5]); // 拽 拽

  ctx.beginPath();
  switch (mode) {
    case Mode.drawLine:
      ctx.moveTo(startPoint.x, startPoint.y);
      ctx.lineTo(currentPoint.x, currentPoint.y);
      break;

    case Mode.drawRectangle:
      ctx.rect(
        Math.min(startPoint.x, currentPoint.x),
        Math.min(startPoint.y, currentPoint.y),
        Math.abs(currentPoint.x - startPoint.x),
        Math.abs(currentPoint.y - startPoint.y)
      );
      break;

    case Mode.drawCircle:
      const dx = currentPoint.x - startPoint.x;
      const dy = currentPoint.y - startPoint.y;
      const radius = Math.sqrt(dx * dx + dy * dy);
      ctx.arc(startPoint.x, startPoint.y, radius, 0, Math.PI * 2);
      break;

    default:
      ctx.setLineDash([]);
      return;
  }

  ctx.stroke();
  ctx.setLineDash([]);
}

// File: src/components/Drawing/Angleshape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface AngleShapeArgs {
    x0: number,
    y0: number,
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    color?: string,
    lineWidth?: number
}


export class AngleShape implements IDrawingShape {

    constructor(
        public x0: number,
        public y0: number,
        public x1: number,
        public y1: number,
        public x2: number,
        public y2: number,
        public color: string = 'teal',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {

        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.x0, this.y0);
        ctx.lineTo(this.x1, this.y1);
        ctx.moveTo(this.x0, this.y0);
        ctx.lineTo(this.x2, this.y2);
        ctx.stroke();
        const angleDeg = this.calculateAngle();
    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        return this.isPointNearLine(x, y, this.x0, this.y0, this.x1, this.y1, tolerance) ||
            this.isPointNearLine(x, y, this.x0, this.y0, this.x2, this.y2, tolerance);
    }

    private isPointNearLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, tolerance: number): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }

    private calculateAngle(): number {
        const v1 = {x: this.x1 - this.x0, y: this.y1 - this.y0};
        const v2 = {x: this.x2 - this.x0, y: this.y2 - this.y0};
        const dot = v1.x * v2.x + v1.y * v2.y;
        const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
        const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
        const cos = dot / (mag1 * mag2);
        return Math.acos(cos) * (100 / Math.PI);
    }
}

// File: src/components/Drawing/ArrowShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface ArrowShapeArgs {
    fromX: number,
    fromY: number,
    toX: number,
    toY: number,
    color?: string,
    lineWidth?: number
}

export class ArrowShape implements IDrawingShape {

    constructor(
        public fromX: number,
        public fromY: number,
        public toX: number,
        public toY: number,
        public color: string = 'black',
        public lineWidth: number = 2
    ) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        const headLength = 10;
        const dx = this.toX - this.fromX;
        const dy = this.toY - this.fromY;
        const angle = Math.atan2(dy, dx);

        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.fromX, this.fromY);
        ctx.lineTo(this.toX, this.toY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(this.toX, this.toY);
        ctx.lineTo(this.toX - headLength * Math.cos(angle - Math.PI / 6), this.toY - headLength * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(this.toX - headLength * Math.cos(angle + Math.PI / 6), this.toY - headLength * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(this.toX, this.toY);
        ctx.fillStyle = this.color;
        ctx.fill();

    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        return this.isPointNearLine(x, y, this.fromX, this.fromY, this.toX, this.toY, tolerance);
    }

    private isPointNearLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, tolerance: number): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }

}

// File: src/components/Drawing/CircleShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface CircleShapeArgs {
    centerX: number,
    centerY: number,
    radius: number,
    color?: string,
    lineWidth?: number
}

export class CircleShape implements IDrawingShape {
    constructor(
        public centerX: number,
        public centerY: number,
        public radius: number,
        public color: string = 'black',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.arc(this.centerX, this.centerY, this.radius, 0, Math.PI * 2);
    }

    isHit(x: number, y: number): boolean {
        const dx = x - this.centerX;
        const dy = y - this.centerY;
        return Math.sqrt(dx * dx + dy * dy) <= this.radius + this.lineWidth / 2;
    }
}

// File: src/components/Drawing/CustomSymbolShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface CustomSymbolShapeArgs {
    x: number,
    y: number,
    symbol: string,
    size: number,
    color: string
}

export class CustomSymbolShape implements IDrawingShape {

    constructor(
        public x: number,
        public y: number,
        public symbol: string = '*',
        public size: number = 24,
        public color: string = 'black') {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        ctx.fillStyle = this.color;
        ctx.font = `${this.size}px Arial`;
        ctx.fillText(this.symbol, this.x, this.y);
    }

    isHit(x: number, y: number): boolean {
        const halfSize = this.size / 2;
        return (
            x >= this.x - halfSize &&
            x <= this.x + halfSize &&
            y >= this.y - halfSize &&
            y <= this.y + halfSize
        );
    }

}

// File: src/components/Drawing/IDrawingShape.ts
export interface IDrawingShape {
    draw(ctx: CanvasRenderingContext2D): void;
    isHit(x: number, y: number): boolean;
}

// File: src/components/Drawing/LineShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface LineShapeArgs {
    startX: number,
    startY: number,
    endX: number,
    endY: number,
    color?: string,
    lineWidth?: number
}

export class LineShape implements IDrawingShape {
    constructor(
        public startX: number,
        public startY: number,
        public endX: number,
        public endY: number,
        public color: string = 'black',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.startX, this.startY);
        ctx.lineTo(this.endX, this.endY);
        ctx.stroke();
    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        return this.isPointNearLine(x, y, this.startX, this.startY, this.endX, this.endY, tolerance);
    }

    private isPointNearLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, tolerance: number): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }
}

// File: src/components/Drawing/Polyline.ts
import {IDrawingShape} from "./IDrawingShape.ts";

interface Point {
    x: number,
    y: number
}

export interface PolylineShapeArgs {
    points: Point[],
    color?: string,
    lineWidth?: number
}


export class Polyline implements IDrawingShape {

    constructor(
        public points: Point[],
        public color: string = 'navy',
        public lineWidth: number = 2
    ) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        if (this.points?.length < 2) return;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.points[0].x, this.points[0].y);
        this.points.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
        ctx.stroke();
    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        for (let i = 0; i < this.points.length - 1; i++) {
            const p1 = this.points[i];
            const p2 = this.points[i + 1];
            if (this.isPointNearLine(x, y, p1.x, p1.y, p2.x, p2.y, tolerance)) {
                return true;
            }
        }
        return false;
    }

    private isPointNearLine(
        px: number, py: number,
        x1: number, y1: number,
        x2: number, y2: number,
        tolerance: number
    ): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }
}

// File: src/components/Drawing/RectangleShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface RectangleShapeArgs {
    x: number,
    y: number,
    width: number,
    height: number,
    color?: string,
    lineWidth?: number
}


export class RectangleShape implements IDrawingShape {
    constructor(
        public x: number,
        public y: number,
        public width: number,
        public height: number,
        public color: string = 'blue',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.strokeRect(this.x, this.y, this.width, this.height);
    }

    isHit(x: number, y: number): boolean {
        return (
            x >= this.x &&
            x <= this.x + this.width &&
            y >= this.y &&
            y <= this.y + this.height
        );
    }
}

// File: src/components/Drawing/TriangleShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface TriangleShapeArgs {
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    x3: number,
    y3: number,
    color?: string,
    lineWidth?: number
}


export class TriangleShape implements IDrawingShape {

    constructor(
        public x1: number,
        public y1: number,
        public x2: number,
        public y2: number,
        public x3: number,
        public y3: number,
        public color: string = 'black',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {

        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.x1, this.y1);
        ctx.lineTo(this.x2, this.y2);
        ctx.lineTo(this.x3, this.y3);
        ctx.closePath();
        ctx.stroke();
    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        return (
            this.isPointNearLine(x, y, this.x1, this.y1, this.x2, this.y2, tolerance) ||
            this.isPointNearLine(x, y, this.x2, this.y2, this.x3, this.y3, tolerance) ||
            this.isPointNearLine(x, y, this.x3, this.y3, this.x1, this.y1, tolerance)
        );
    }

    private isPointNearLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, tolerance: number): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }
}

// File: src/components/Drawing/types.ts
import {Mode} from "../../contexts/ModeContext.tsx";

export type Drawing = {
    mode: Mode;
    args: any; // 转 祝 -type 拽 转专  砖
}

// File: src/components/Toolbar/ModeButton.tsx


import React from 'react';
import { Mode } from '../../contexts/ModeContext';

interface ModeButtonProps {
  mode: Mode;
  currentMode: Mode;
  onClick: (mode: Mode) => void;
  label: string;
}

const ModeButton: React.FC<ModeButtonProps> = ({ mode, currentMode, onClick, label }) => {
  const selected = mode === currentMode;
  return (
    <button
      className={selected ? 'selected' : ''}
      onClick={() => onClick(mode)}
    >
      {label}
    </button>
  );
};

export default ModeButton;

// File: src/components/Toolbar/SettingsToolbar.tsx
import React from 'react';
import '../../styles/SettingsToolbar.scss';
export const SettingsToolbar: React.FC = () => {
    const handleDownload = () => {
        const canvas = document.querySelector('Canvas');
        if (!canvas) return;
        const link = document.createElement('a');
        link.download = 'chart-snapshot.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
    };

    return (
        <div className={'settings-toolbar'}>
            <input type="text" placeholder="Symbol"/>
            <select>
                <option value="1m">1 Min</option>
                <option value="5m">5 Min</option>
                <option value="1h">1 Hour</option>
                <option value="1d">1 Day</option>
            </select>
            <select>
                <option value="50">50 Bars</option>
                <option value="100">100 Bars</option>
                <option value="200">200 Bars</option>
            </select>
            <select>
                <option value="candlestick">Candlestick</option>
                <option value="line">Line</option>
            </select>
            <button onClick={handleDownload}> Snapshot</button>
            <button>锔 Settings</button>
        </div>
    );
};

// File: src/components/Toolbar/Toolbar.tsx
import React from 'react';
import { Mode, useMode } from '../../contexts/ModeContext';
import ModeButton from './ModeButton';
import '../../styles/Toolbar.scss';

export const Toolbar: React.FC = () => {
  const { mode, setMode } = useMode();

  return (
    <div className={'toolbar-container'}>
      <div className={'toolbar'}>
        <ModeButton mode={Mode.drawLine} currentMode={mode} onClick={setMode} label="D Line" />
        <ModeButton mode={Mode.drawRectangle} currentMode={mode} onClick={setMode} label="D Rect" />
        <ModeButton mode={Mode.drawCircle} currentMode={mode} onClick={setMode} label="D Cir" />
        <ModeButton mode={Mode.drawTriangle} currentMode={mode} onClick={setMode} label="D Triangle" />
        <ModeButton mode={Mode.drawAngle} currentMode={mode} onClick={setMode} label="D Angle" />
        <ModeButton mode={Mode.select} currentMode={mode} onClick={setMode} label="Select" />
        <ModeButton mode={Mode.editShape} currentMode={mode} onClick={setMode} label="Edit" />
      </div>
    </div>
  );
};

// File: src/contexts/ModeContext.tsx
import React, {createContext, useContext, useState} from 'react';

export enum Mode {
    none,
    drawLine,
    drawRectangle,
    drawCircle,
    drawTriangle,
    drawAngle,
    select,
    editShape,
    drawPolyline,
    drawArrow,
    drawCustomSymbol,
    drawText
}

interface ModeContextProps {
    mode: Mode;
    setMode: (mode: Mode) => void;
}

const ModeContext = createContext<ModeContextProps | undefined>(undefined);

export const ModeProvider: React.FC<{ children: React.ReactNode }> = ({children}) => {
    const [mode, setModeState] = useState<Mode>(Mode.none);

    const setMode = (newMode: Mode) => {
        setModeState(prev => (prev === newMode ? Mode.none : newMode));
    };

    return (
        <ModeContext.Provider value={{mode, setMode}}>
            {children}
        </ModeContext.Provider>
    );
};

export const useMode = (): ModeContextProps => {
    const context = useContext(ModeContext);
    if (!context) {
        throw new Error('useMode must be used within a ModeProvider');
    }
    return context;
};

// File: src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import {App} from './components/App';
import {ModeProvider} from './contexts/ModeContext';

const root = document.getElementById('root') as HTMLElement;

ReactDOM.createRoot(root).render(
    <React.StrictMode>
        <ModeProvider>
            <App/>
        </ModeProvider>
    </React.StrictMode>
);

// File: src/store/useChartStore.ts
import {create} from 'zustand';
import type { Candle } from '../types/Candle.ts';

interface ChartState {
    numberOfXTicks: number;
    numberOfYTicks: number;
    timeFormat: string;
    visibleRange: { start: number; end: number };
    canvasWidth: number;
    canvasHeight: number;
    setCanvasWidth: (width: number) => void;
    setCanvasHeight: (height: number) => void;
    setNumberOfXTicks: (n: number) => void;
    setNumberOfYTicks: (n: number) => void;
    setTimeFormat: (format: string) => void;
    setVisibleRange: (range: { start: number; end: number }) => void;

    // Drawing state
    drawings: any[]; // 驻砖专 祝 住 拽 转专
    setDrawings: (drawings: any[] | ((prev: any[]) => any[])) => void;
    selectedIndex: number | null;
    setSelectedIndex: (index: number | null) => void;

    // Mode
    mode: string;
    setMode: (mode: string) => void;

    // Is Drawing
    isDrawing: boolean;
    setIsDrawing: (val: boolean) => void;

    // Points
    startPoint: { x: number; y: number } | null;
    setStartPoint: (point: { x: number; y: number } | null) => void;
    currentPoint: { x: number; y: number } | null;
    setCurrentPoint: (point: { x: number; y: number } | null) => void;

    stepX: number;
    stepY: number;
    strokeStyle: string;
    padding: number;
    width: number;
    height: number;

    setStepX: (value: number) => void;
    setStepY: (value: number) => void;
    setStrokeStyle: (value: string) => void;
    setPadding: (value: number) => void;
    setWidth: (value: number) => void;
    setHeight: (value: number) => void;

    minPrice: number;
    maxPrice: number;
    setMinPrice: (value: number) => void;
    setMaxPrice: (value: number) => void;

    yAxisPosition: 'left' | 'right';
    setYAxisPosition: (position: 'left' | 'right') => void;

    priceDecimalPlaces: number;
    setPriceDecimalPlaces: (value: number) => void;

    decimalSeparator: string;
    setDecimalSeparator: (value: string) => void;

    thousandSeparator: string;
    setThousandSeparator: (value: string) => void;

    currencySymbol: string;
    setCurrencySymbol: (value: string) => void;

    currencySymbolPosition: 'before' | 'after';
    setCurrencySymbolPosition: (value: 'before' | 'after') => void;

    safeCandles: Candle[];
    visibleCandles: Candle[];
    candlesToUse: Candle[];
    setCandlesAndVisibleRange: (candles: Candle[], visibleRange: { start: number; end: number }) => void;
}

export const useChartStore = create<ChartState>((set) => ({
    numberOfXTicks: 5,
    numberOfYTicks: 5,
    timeFormat: 'YYYY/MM/DD',
    visibleRange: {start: Date.now() - 365 * 24 * 60 * 60 * 1000, end: Date.now()},
    canvasWidth: 800,
    canvasHeight: 600,
    setCanvasWidth: (width) => set({canvasWidth: width}),
    setCanvasHeight: (height) => set({canvasHeight: height}),
    setNumberOfXTicks: (n) => set({numberOfXTicks: n}),
    setNumberOfYTicks: (n) => set({numberOfYTicks: n}),
    setTimeFormat: (format) => set({timeFormat: format}),
    setVisibleRange: (range) => set({visibleRange: range}),

    drawings: [],
    setDrawings: (update) => set(state => ({
        drawings: typeof update === 'function' ? update(state.drawings) : update
    })),
    selectedIndex: null,
    setSelectedIndex: (index) => set({selectedIndex: index}),

    mode: 'none',
    setMode: (mode) => set({mode}),

    isDrawing: false,
    setIsDrawing: (val) => set({isDrawing: val}),

    startPoint: null,
    setStartPoint: (point) => set({startPoint: point}),

    currentPoint: null,
    setCurrentPoint: (point) => set({currentPoint: point}),

    stepX: 50,
    stepY: 50,
    strokeStyle: '#eee',
    padding: 20,
    width: 800,
    height: 600,

    setStepX: (value) => set({stepX: value}),
    setStepY: (value) => set({stepY: value}),
    setStrokeStyle: (value) => set({strokeStyle: value}),
    setPadding: (value) => set({padding: value}),
    setWidth: (value) => set({width: value}),
    setHeight: (value) => set({height: value}),

    minPrice: 0,
    maxPrice: 100,
    setMinPrice: (value) => set({minPrice: value}),
    setMaxPrice: (value) => set({maxPrice: value}),

    yAxisPosition: 'left',
    setYAxisPosition: (position) => set({yAxisPosition: position}),

    priceDecimalPlaces: 2,
    setPriceDecimalPlaces: (value) => set({ priceDecimalPlaces: value }),

    decimalSeparator: '.',
    setDecimalSeparator: (value) => set({ decimalSeparator: value }),

    thousandSeparator: ',',
    setThousandSeparator: (value) => set({ thousandSeparator: value }),

    currencySymbol: '$',
    setCurrencySymbol: (value) => set({ currencySymbol: value }),

    currencySymbolPosition: 'before',
    setCurrencySymbolPosition: (value) => set({ currencySymbolPosition: value }),

    safeCandles: [],
    visibleCandles: [],
    candlesToUse: [],
    setCandlesAndVisibleRange: (candles, visibleRange) => set(state => {
        const safeCandles = candles || [];
        const visibleCandles = safeCandles.filter(
            c => visibleRange && c.t >= visibleRange.start && c.t <= visibleRange.end
        );
        const candlesToUse = visibleCandles.length > 0 ? visibleCandles : safeCandles;
        const prices = candlesToUse.length > 0
            ? candlesToUse.flatMap(c => [c.h, c.l])
            : [];
        const maxPrice = prices.length > 0 ? Math.max(...prices) : 1;
        const minPrice = prices.length > 0 ? Math.min(...prices) : 0;
        return {
            safeCandles,
            visibleCandles,
            candlesToUse,
            minPrice,
            maxPrice
        };
    }),
}));

// File: src/styles/App.scss
//make the html file to cover the whole screen
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
    overflow: hidden; /* 注  转专转 */
}

#root {
  height: calc(100% - 4px); /* 专  砖 -toolbar */
  width: calc(100% - 4px); /* 专 专 砖 -toolbar */
  margin: 2px;
  padding: 0;
  display: flex;
  flex-direction: column;
  overflow: hidden; /* 注  转专转 */
}

// make the app container to cover the whole screen
.main-app-window {
  display: flex;
  flex-direction: column;
  position: relative;
  height: 100%;
  width: 100%;
  padding: 2px;
  box-sizing: border-box;
  overflow: hidden; /* 注  转专转 */
}

.settings-area {
  display: flex;
  flex-direction: row;
  height: 30px;
  width: 100%;
}

.lower-container {
  height: calc(100% - 40px);
  width: 100%;
  display: flex;
  flex-direction: row;
  overflow: hidden; /* 注  驻拽转 */
}

//   拽转 拽抓 专, 住祝 :
.chart-canvas-container {
  flex-grow: 1;
  width: calc(100% - 40px); /* 专 专 砖 -toolbar */
  height: 100%;
  position: relative;
}

.toolbar-container {
  width: 40px; /* 专 住专  */
  height: 100%;
  flex-shrink: 0; /* 注 抓 */
}

// File: src/styles/Canvas/Axes.scss


// File: src/styles/Canvas/Grid.scss


// File: src/styles/ChartCanves.scss
.chart-canvas-container {
  flex-grow: 1;
  width: calc(100% - 40px); /* 专 专 砖 -toolbar */
  height: 100%;
  position: relative;
  display: block;
  max-height: 100%;
}

// File: src/styles/Drawing.scss


// File: src/styles/Overlays.scss


// File: src/styles/SettingsToolbar.scss

.settings-toolbar {
  background: #ddd;
  display: flex;
  height: 100%;
  width: 100%;
  justify-content: start;
  align-content: center;
  align-items: center;

  input, select, button {
    height: 100%;
    border-radius: 3px;
    border-width: 1px;
    width: fit-content;
    font-size: 11px;
    padding: 0 5px;
  }

  input {
    height: calc(100% - 2px);
    width: 100px;
  }

}

// File: src/styles/Toolbar.scss
@use '../styles/variables' as v;

.toolbar-container {
  display: flex;
  flex-grow: 0;
  flex-shrink: 0;
  width: v.$toolbar-width;
  background-color: #ddd;
  height: 100%;
}

.toolbar {
  width: v.$toolbar-width;
  height: 100%;
  display: grid;
  grid-column: 1;
  grid-auto-flow: row;
  grid-template-rows: auto;
  grid-template-columns: auto;
  align-content: start;

  button {
    display: flex;
    min-height: v.$toolbar-width;
    width: 100%;
    flex-grow: 1;
    padding: 0;
    overflow: hidden;
    text-align: center;
    font-size: 10px;

    &.selected {
      background-color: #333;
      color: #fff;
      border-left: 3px solid #007bff;
    }
  }
}

// File: src/styles/_variables.scss

$toolbar-width: 40px;

// File: src/types/Candle.ts
// 驻住 Candle 注 砖转 t, o, c, l, h
export interface Candle {
    t: number; // timestamp
    o: number; // open
    c: number; // close
    l: number; // low
    h: number; // high
}

export interface CandleWithIndex extends Candle {
    index: number; // index in the original array
}

export interface TimeRange {
    start: number; // timestamp 转
    end: number;   // timestamp 住
}

// File: src/types/chartStyleOptions.d.ts
// chartStyleOptions.ts

// Candles style
import {AxesPosition} from "./types.ts";

export interface CandleStyleOptions {
    upColor?: string;
    downColor?: string;
    borderColor?: string;
    borderWidth?: number;
    bodyWidthFactor?: number;
    spacingFactor?: number;
}

// Grid style
export interface GridStyleOptions {
    gridSpacing?: number;
    lineColor?: string;
    lineWidth?: number;
    lineDash?: number[];
}

// Axes style
export interface AxesStyleOptions {
    axisPosition?: AxesPosition;
    textColor?: string;
    font?: string;
    lineColor?: string;
    lineWidth?: number;
    numberLocale?: string;
    dateLocale?: string;
    numberFractionDigits?: number; // Number of decimal places to format axis values
}
export interface LineOverlayOptions{
    color?: string;
    lineWidth?: number;
    dashed?: boolean;
}
// Main Chart style options
export interface ChartStyleOptions {
    candles?: CandleStyleOptions;
    grid?: GridStyleOptions;
    axes?: AxesStyleOptions;
    lineOverlay?:LineOverlayOptions;
    backgroundColor?:string;
    // 驻砖专 住祝 驻 注 (砖 lineOverlay ')
}

// File: src/types/types.ts
import {ChartStyleOptions} from "./chartStyleOptions";

// Enum for Axis position
export enum AxesPosition {
    left = 'left',
    right = 'right',
}

// Base chart options
interface BaseChartOptions {
    theme?: 'light' | 'dark' | 'grey' | string;
    showOverlayLine?: boolean;
    style?: Partial<ChartStyleOptions>;
}

// Line chart data point
export interface LineData {
    time: number;
    value: number;
}

// Candlestick chart data point (full)
export interface CandleData {
    time: number;
    open: number;
    high: number;
    low: number;
    close: number;
}

// Candlestick chart data point (compact)
export interface CandleDataCompact {
    t: number;
    o: number;
    h: number;
    l: number;
    c: number;
}

// Line chart options
export interface LineChartOptions extends BaseChartOptions {
    type: 'line';
    data: LineData[];
}

// Candlestick chart options
export interface CandleChartOptions extends BaseChartOptions {
    type: 'candlestick';
    data: (CandleData | CandleDataCompact)[];
}

// Unified ChartOptions type
export type ChartOptions = LineChartOptions | CandleChartOptions;

// File: src/vite-env.d.ts
/// <reference types="vite/client" />


