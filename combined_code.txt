// File: src/components/App.tsx
import React from 'react';
import {ChartCanvas} from './Canvas/ChartCanvas.tsx';
import {Toolbar} from './Toolbar/Toolbar.tsx';
import {SettingsToolbar} from './Toolbar/SettingsToolbar.tsx';
import '../styles/App.scss';

export const App: React.FC = () => {
    return (
        <div className={'main-app-window'}>
            <div className={'settings-area'}>
                <SettingsToolbar/>
            </div>
            <div className={'lower-container'}>
                <ChartCanvas/>
                <Toolbar/>
            </div>
        </div>
    );
};

// File: src/components/Canvas/BackgroundLayer.tsx
import React, {useEffect, useRef} from 'react';
import {Mode} from '../../contexts/ModeContext';
import {Drawing} from '../Drawing/types'; //  砖砖 驻住 Drawing 拽 转
import {Candle} from '../../types/Candle';
import {LineShape} from '../Drawing/LineShape';
import {RectangleShape} from '../Drawing/RectangleShape';
import {CircleShape} from '../Drawing/CircleShape';
import {drawCandlesticks} from './utils/drawCandlesticks.ts';

interface BackgroundLayerProps {
    drawings: Drawing[];
    selectedIndex: number | null;
    candles: Candle[];
    visibleRange: { start: number; end: number };
    width: number;
    height: number;
}

export const BackgroundLayer: React.FC<BackgroundLayerProps> = ({
                                                                    drawings,
                                                                    selectedIndex,
                                                                    candles,
                                                                    visibleRange,
                                                                    width,
                                                                    height,
                                                                }) => {
    const canvasRef = useRef<HTMLCanvasElement | null>(null);

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);

        // 拽 专拽注
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, width, height);

        // 爪专 爪专转
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        drawings.forEach((d) => {
            ctx.beginPath();
            if (d.mode === Mode.drawLine) {
                const args = d.args as any;
                const line = new LineShape(args.startX, args.startY, args.endX, args.endY);
                line.draw(ctx);
            } else if (d.mode === Mode.drawRectangle) {
                const args = d.args as any;
                const rect = new RectangleShape(args.x, args.y, args.width, args.height);
                rect.draw(ctx);
            } else if (d.mode === Mode.drawCircle) {
                const args = d.args as any;
                const circ = new CircleShape(args.centerX, args.centerY, args.radius);
                circ.draw(ctx);
            }
            ctx.stroke();
        });

        // 砖转 爪专 专转
        if (selectedIndex !== null && drawings[selectedIndex]) {
            const d = drawings[selectedIndex];
            let shape = null;
            if (d.mode === Mode.drawLine) {
                const args = d.args as any;
                shape = new LineShape(args.startX, args.startY, args.endX, args.endY);
            } else if (d.mode === Mode.drawRectangle) {
                const args = d.args as any;
                shape = new RectangleShape(args.x, args.y, args.width, args.height);
            } else if (d.mode === Mode.drawCircle) {
                const args = d.args as any;
                shape = new CircleShape(args.centerX, args.centerY, args.radius);
            }
            if (shape) {
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                shape.draw(ctx);
            }
        }

        // 爪专 专转  专
        const visibleCandles = candles.slice(visibleRange.start, visibleRange.end);
        drawCandlesticks(ctx, visibleCandles, canvas);
    }, [drawings, selectedIndex, candles, visibleRange, width, height]);

    return (
        <canvas
            ref={canvasRef}
            style={{position: 'absolute', top: 0, left: 0, zIndex: 0, width, height}}
            width={width}
            height={height}
        />
    );
};

export default BackgroundLayer;

// File: src/components/Canvas/ChartCanvas.tsx
import React, { useRef, useEffect, useState } from 'react';
import { Mode, useMode } from '../../contexts/ModeContext';
import { Drawing } from '../Drawing/types';

interface ChartCanvasProps {
  candles: Candle[];
  width: number;
  height: number;
  visibleRange?: { start: number; end: number };
}

import { drawGrid } from './utils/drawGrid';
import { drawAxes } from './utils/drawAxes';
import { drawCandlesticks } from './utils/drawCandlesticks';
import { drawDrawings } from './utils/drawDrawings';
import { drawOverlay } from './utils/drawOverlay';
import {Candle} from "../../types/Candle.ts";

export const ChartCanvas: React.FC<ChartCanvasProps> = ({
  candles,
  width,
  height,
  visibleRange: initialVisibleRange,
}) => {
  const { mode } = useMode();
  const [isDrawing, setIsDrawing] = useState(false);
  const [startPoint, setStartPoint] = useState<{ x: number; y: number } | null>(null);
  const [currentPoint, setCurrentPoint] = useState<{ x: number; y: number } | null>(null);
  const [drawings, setDrawings] = useState<Drawing[]>([]);
  const [selectedIndex, setSelectedIndex] = useState<number | null>(null);

  // 专转  爪驻 驻   住驻拽 驻专驻住
  const [visibleRange, setVisibleRange] = useState<{ start: number; end: number }>(
    initialVisibleRange || { start: 0, end: candles.length }
  );

  const padding = 40;

  // 砖  拽住 转 转 专转  专
  const visibleCandles = candles.slice(visibleRange.start, visibleRange.end);
  const prices = visibleCandles.flatMap(c => [c.h, c.l]);
  const maxPrice = Math.max(...prices);
  const minPrice = Math.min(...prices);

  //  专注 - mouse
  const canvasRef = useRef<HTMLCanvasElement | null>(null);

  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!canvasRef.current) return;
    const rect = canvasRef.current!.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (mode === Mode.select) {
      // 拽  爪 注 爪专 拽转
      for (let i = 0; i < drawings.length; i++) {
        const d = drawings[i];
        let shape = null;
        if (d.mode === Mode.drawLine) {
          // @ts-ignore
          shape = new LineShape(d.args.startX, d.args.startY, d.args.endX, d.args.endY);
        } else if (d.mode === Mode.drawRectangle) {
          // @ts-ignore
          shape = new RectangleShape(d.args.x, d.args.y, d.args.width, d.args.height);
        } else if (d.mode === Mode.drawCircle) {
          // @ts-ignore
          shape = new CircleShape(d.args.centerX, d.args.centerY, d.args.radius);
        }
        if (shape && shape.isHit(x, y)) {
          setSelectedIndex(i);
          return;
        }
      }
      setSelectedIndex(null);
      return;
    }

    if (mode !== Mode.none) {
      setStartPoint({ x, y });
      setIsDrawing(true);
    }
  };

  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDrawing || !startPoint || mode === Mode.none) return;
    if (!canvasRef.current) return;

    const rect = canvasRef.current!.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    setCurrentPoint({ x, y });
  };

  const handleMouseUp = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDrawing || !startPoint || mode === Mode.none) return;
    if (!canvasRef.current) return;

    const rect = canvasRef.current!.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    setDrawings(prev => {
      if (mode === Mode.drawLine) {
        return [
          ...prev,
          {
            mode: Mode.drawLine,
            args: {
              startX: startPoint.x,
              startY: startPoint.y,
              endX: x,
              endY: y,
            },
          },
        ];
      } else if (mode === Mode.drawRectangle) {
        return [
          ...prev,
          {
            mode: Mode.drawRectangle,
            args: {
              x: startPoint.x,
              y: startPoint.y,
              width: x - startPoint.x,
              height: y - startPoint.y,
            },
          },
        ];
      } else if (mode === Mode.drawCircle) {
        const dx = x - startPoint.x;
        const dy = y - startPoint.y;
        const radius = Math.sqrt(dx * dx + dy * dy);
        return [
          ...prev,
          {
            mode: Mode.drawCircle,
            args: {
              centerX: startPoint.x,
              centerY: startPoint.y,
              radius,
            },
          },
        ];
      }
      return prev;
    });

    setIsDrawing(false);
    setStartPoint(null);
    setCurrentPoint(null);
  };

  // 驻拽爪转 爪专 专转
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);

    ctx.clearRect(0, 0, width, height);

    drawGrid(ctx, width, height, padding);
    drawAxes(ctx, candles, visibleRange, width, height, padding, minPrice, maxPrice);
    drawCandlesticks(ctx, candles, visibleRange, width, height, padding, minPrice, maxPrice);
    drawDrawings(ctx, drawings, selectedIndex);
    drawOverlay(ctx, mode, isDrawing, startPoint, currentPoint);

  }, [
    candles,
    visibleRange,
    drawings,
    selectedIndex,
    mode,
    isDrawing,
    startPoint,
    currentPoint,
    width,
    height,
    padding,
    minPrice,
    maxPrice,
  ]);

  return (
    <canvas
      ref={canvasRef}
      style={{ width, height, userSelect: 'none', display: 'block' }}
      onMouseDown={handleMouseDown}
      onMouseMove={handleMouseMove}
      onMouseUp={handleMouseUp}
    />
  );
};

// File: src/components/Canvas/utils/drawAxes.ts
import {Candle} from "../../../types/Candle.ts";

export function drawAxes(
    ctx: CanvasRenderingContext2D,
    candles: Candle[],
    visibleRange: { start: number; end: number },
    width: number,
    height: number,
    padding: number,
    minPrice: number,
    maxPrice: number
) {
    ctx.strokeStyle = '#333';
    ctx.fillStyle = '#333';
    ctx.lineWidth = 1;
    ctx.font = '12px Arial';

    ctx.textBaseline = 'middle';

    // 爪专 拽 驻拽 (爪专 Y) 注 住 专
    const priceRange = maxPrice - minPrice;
    const yTicks = 5;
    const yStep = (height - 2 * padding) / yTicks;
    ctx.textAlign = 'right';

    for (let i = 0; i <= yTicks; i++) {
        const y = padding + i * yStep;
        const price = maxPrice - (priceRange / yTicks) * i;

        // 拽 驻拽
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(width - padding, y);
        ctx.stroke();

        // 拽住 专 爪 砖
        ctx.fillText(price.toFixed(2), padding - 5, y);
    }

    // 爪专 拽  (爪专 X) 注 住 
    const candleCount = visibleRange.end - visibleRange.start;
    if (candleCount === 0) return;

    const xStep = (width - 2 * padding) / candleCount;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';

    const visibleCandles = candles.slice(visibleRange.start, visibleRange.end);

    // 爪 住   N 专转 (  注住)
    const stepInterval = Math.max(1, Math.floor(candleCount / 10));

    for (let i = 0; i < candleCount; i++) {
        if (i % stepInterval === 0) {
            const x = padding + i * xStep + xStep / 2;
            const candle = visibleCandles[i];
            const date = new Date(candle.t);
            const label = `${date.getHours()}:${date.getMinutes().toString().padStart(2, '0')}`;

            // 拽 
            ctx.beginPath();
            ctx.moveTo(x, height - padding);
            ctx.lineTo(x, padding);
            ctx.stroke();

            // 拽住  转转 爪专 X
            ctx.fillText(label, x, height - padding + 5);
        }
    }

    // 爪专 住专转 爪转 爪专
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, height - padding);
    ctx.lineTo(width - padding, height - padding);
    ctx.stroke();
}

// File: src/components/Canvas/utils/drawCandlesticks.ts
import { Candle } from '../../../types/Candle';

export function drawCandlesticks(
  ctx: CanvasRenderingContext2D,
  candles: Candle[],
  visibleRange: { start: number; end: number },
  width: number,
  height: number,
  padding: number,
  minPrice: number,
  maxPrice: number
): void {
  const dpr = window.devicePixelRatio || 1;
  const drawableWidth = width - 2 * padding;
  const drawableHeight = height - 2 * padding;

  const candleCount = visibleRange.end - visibleRange.start;
  if (candleCount <= 0) return;

  const candleSpacing = drawableWidth / candleCount;
  const candleWidth = candleSpacing * 0.6;

  const priceRange = maxPrice - minPrice;

  // 驻拽爪 专转 专 拽 Y 拽住
  const priceToY = (price: number) => {
    return padding + drawableHeight * (1 - (price - minPrice) / priceRange);
  };

  const visibleCandles = candles.slice(visibleRange.start, visibleRange.end);

  visibleCandles.forEach((candle, i) => {
    const x = padding + i * candleSpacing;
    const highY = priceToY(candle.h);
    const lowY = priceToY(candle.l);
    const openY = priceToY(candle.o);
    const closeY = priceToY(candle.c);

    const isUp = candle.c >= candle.o;

    ctx.strokeStyle = isUp ? 'green' : 'red';
    ctx.fillStyle = isUp ? 'green' : 'red';
    ctx.lineWidth = 1;

    // 爪专 -wick (拽 注 转转)
    ctx.beginPath();
    ctx.moveTo(x + candleWidth / 2, highY);
    ctx.lineTo(x + candleWidth / 2, lowY);
    ctx.stroke();

    // 爪专 祝 专
    const bodyY = Math.min(openY, closeY);
    const bodyHeight = Math.max(1, Math.abs(openY - closeY)); // 驻转 1 驻拽住 
    ctx.fillRect(x, bodyY, candleWidth, bodyHeight);
  });
}



// File: src/components/Canvas/utils/drawDrawings.ts


import { Drawing } from '../../Drawing/types';
import { LineShape } from '../../Drawing/LineShape';
import { RectangleShape } from '../../Drawing/RectangleShape';
import { CircleShape } from '../../Drawing/CircleShape';
import { TriangleShape } from '../../Drawing/TriangleShape';
import { AngleShape } from '../../Drawing/AngleShape';
import { Polyline } from '../../Drawing/Polyline';
import { ArrowShape } from '../../Drawing/ArrowShape';
import { CustomSymbolShape } from '../../Drawing/CustomSymbolShape';
import { Mode } from '../../../contexts/ModeContext';

export function drawDrawings(
  ctx: CanvasRenderingContext2D,
  drawings: Drawing[],
  selectedIndex: number | null
): void {
  drawings.forEach((d, index) => {
    ctx.beginPath();
    let shape = null;
    switch (d.mode) {
      case Mode.drawLine:
        shape = new LineShape(
          d.args.startX,
          d.args.startY,
          d.args.endX,
          d.args.endY
        );
        break;
      case Mode.drawRectangle:
        shape = new RectangleShape(
          d.args.x,
          d.args.y,
          d.args.width,
          d.args.height
        );
        break;
      case Mode.drawCircle:
        shape = new CircleShape(
          d.args.centerX,
          d.args.centerY,
          d.args.radius
        );
        break;
      case Mode.drawTriangle:
        shape = new TriangleShape(
          d.args.x1,
          d.args.y1,
          d.args.x2,
          d.args.y2,
          d.args.x3,
          d.args.y3
        );
        break;
      case Mode.drawAngle:
        shape = new AngleShape(
          d.args.x0,
          d.args.y0,
          d.args.x1,
          d.args.y1,
          d.args.x2,
          d.args.y2
        );
        break;
      case Mode.drawPolyline:
        shape = new Polyline(d.args.points);
        break;
      case Mode.drawArrow:
        shape = new ArrowShape(
          d.args.fromX,
          d.args.fromY,
          d.args.toX,
          d.args.toY
        );
        break;
      case Mode.drawCustomSymbol:
        shape = new CustomSymbolShape(
          d.args.x,
          d.args.y,
          d.args.symbol,
          d.args.size,
          d.args.color
        );
        break;
      default:
        break;
    }

    if (shape) {
      if (selectedIndex === index) {
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
      } else {
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
      }
      shape.draw(ctx);
      ctx.stroke();
    }
  });
}

// File: src/components/Canvas/utils/drawGrid.ts
export function drawGrid(
  ctx: CanvasRenderingContext2D,
  width: number,
  height: number,
  padding: number,
  stepX: number = 50,
  stepY: number = 50,
  strokeStyle: string = '#eee'
) {
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = 1;

  // 拽 
  for (let x = padding; x <= width - padding; x += stepX) {
    ctx.beginPath();
    ctx.moveTo(x, padding);
    ctx.lineTo(x, height - padding);
    ctx.stroke();
  }

  // 拽 驻拽
  for (let y = padding; y <= height - padding; y += stepY) {
    ctx.beginPath();
    ctx.moveTo(padding, y);
    ctx.lineTo(width - padding, y);
    ctx.stroke();
  }
}


// File: src/components/Drawing/Angleshape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface AngleShapeArgs {
    x0: number,
    y0: number,
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    color?: string,
    lineWidth?: number
}


export class AngleShape implements IDrawingShape {

    constructor(
        public x0: number,
        public y0: number,
        public x1: number,
        public y1: number,
        public x2: number,
        public y2: number,
        public color: string = 'teal',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {

        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.x0, this.y0);
        ctx.lineTo(this.x1, this.y1);
        ctx.moveTo(this.x0, this.y0);
        ctx.lineTo(this.x2, this.y2);
        ctx.stroke();
        const angleDeg = this.calculateAngle();
    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        return this.isPointNearLine(x, y, this.x0, this.y0, this.x1, this.y1, tolerance) ||
            this.isPointNearLine(x, y, this.x0, this.y0, this.x2, this.y2, tolerance);
    }

    private isPointNearLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, tolerance: number): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }

    private calculateAngle(): number {
        const v1 = {x: this.x1 - this.x0, y: this.y1 - this.y0};
        const v2 = {x: this.x2 - this.x0, y: this.y2 - this.y0};
        const dot = v1.x * v2.x + v1.y * v2.y;
        const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
        const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
        const cos = dot / (mag1 * mag2);
        return Math.acos(cos) * (100 / Math.PI);
    }
}

// File: src/components/Drawing/ArrowShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface ArrowShapeArgs {
    fromX: number,
    fromY: number,
    toX: number,
    toY: number,
    color?: string,
    lineWidth?: number
}

export class ArrowShape implements IDrawingShape {

    constructor(
        public fromX: number,
        public fromY: number,
        public toX: number,
        public toY: number,
        public color: string = 'black',
        public lineWidth: number = 2
    ) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        const headLength = 10;
        const dx = this.toX - this.fromX;
        const dy = this.toY - this.fromY;
        const angle = Math.atan2(dy, dx);

        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.fromX, this.fromY);
        ctx.lineTo(this.toX, this.toY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(this.toX, this.toY);
        ctx.lineTo(this.toX - headLength * Math.cos(angle - Math.PI / 6), this.toY - headLength * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(this.toX - headLength * Math.cos(angle + Math.PI / 6), this.toY - headLength * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(this.toX, this.toY);
        ctx.fillStyle = this.color;
        ctx.fill();

    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        return this.isPointNearLine(x, y, this.fromX, this.fromY, this.toX, this.toY, tolerance);
    }

    private isPointNearLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, tolerance: number): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }

}

// File: src/components/Drawing/CircleShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface CircleShapeArgs {
    centerX: number,
    centerY: number,
    radius: number,
    color?: string,
    lineWidth?: number
}

export class CircleShape implements IDrawingShape {
    constructor(
        public centerX: number,
        public centerY: number,
        public radius: number,
        public color: string = 'black',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.arc(this.centerX, this.centerY, this.radius, 0, Math.PI * 2);
    }

    isHit(x: number, y: number): boolean {
        const dx = x - this.centerX;
        const dy = y - this.centerY;
        return Math.sqrt(dx * dx + dy * dy) <= this.radius + this.lineWidth / 2;
    }
}

// File: src/components/Drawing/CustomSymbolShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface CustomSymbolShapeArgs {
    x: number,
    y: number,
    symbol: string,
    size: number,
    color: string
}

export class CustomSymbolShape implements IDrawingShape {

    constructor(
        public x: number,
        public y: number,
        public symbol: string = '*',
        public size: number = 24,
        public color: string = 'black') {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        ctx.fillStyle = this.color;
        ctx.font = `${this.size}px Arial`;
        ctx.fillText(this.symbol, this.x, this.y);
    }

    isHit(x: number, y: number): boolean {
        const halfSize = this.size / 2;
        return (
            x >= this.x - halfSize &&
            x <= this.x + halfSize &&
            y >= this.y - halfSize &&
            y <= this.y + halfSize
        );
    }

}

// File: src/components/Drawing/IDrawingShape.ts
export interface IDrawingShape {
    draw(ctx: CanvasRenderingContext2D): void;
    isHit(x: number, y: number): boolean;
}

// File: src/components/Drawing/LineShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface LineShapeArgs {
    startX: number,
    startY: number,
    endX: number,
    endY: number,
    color?: string,
    lineWidth?: number
}

export class LineShape implements IDrawingShape {
    constructor(
        public startX: number,
        public startY: number,
        public endX: number,
        public endY: number,
        public color: string = 'black',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.startX, this.startY);
        ctx.lineTo(this.endX, this.endY);
        ctx.stroke();
    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        return this.isPointNearLine(x, y, this.startX, this.startY, this.endX, this.endY, tolerance);
    }

    private isPointNearLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, tolerance: number): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }
}

// File: src/components/Drawing/Polyline.ts
import {IDrawingShape} from "./IDrawingShape.ts";

interface Point {
    x: number,
    y: number
}

export interface PolylineShapeArgs {
    points: Point[],
    color?: string,
    lineWidth?: number
}


export class Polyline implements IDrawingShape {

    constructor(
        public points: Point[],
        public color: string = 'navy',
        public lineWidth: number = 2
    ) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        if (this.points?.length < 2) return;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.points[0].x, this.points[0].y);
        this.points.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
        ctx.stroke();
    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        for (let i = 0; i < this.points.length - 1; i++) {
            const p1 = this.points[i];
            const p2 = this.points[i + 1];
            if (this.isPointNearLine(x, y, p1.x, p1.y, p2.x, p2.y, tolerance)) {
                return true;
            }
        }
        return false;
    }

    private isPointNearLine(
        px: number, py: number,
        x1: number, y1: number,
        x2: number, y2: number,
        tolerance: number
    ): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }
}

// File: src/components/Drawing/RectangleShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface RectangleShapeArgs {
    x: number,
    y: number,
    width: number,
    height: number,
    color?: string,
    lineWidth?: number
}


export class RectangleShape implements IDrawingShape {
    constructor(
        public x: number,
        public y: number,
        public width: number,
        public height: number,
        public color: string = 'blue',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.strokeRect(this.x, this.y, this.width, this.height);
    }

    isHit(x: number, y: number): boolean {
        return (
            x >= this.x &&
            x <= this.x + this.width &&
            y >= this.y &&
            y <= this.y + this.height
        );
    }
}

// File: src/components/Drawing/TriangleShape.ts
import {IDrawingShape} from "./IDrawingShape.ts";

export interface TriangleShapeArgs {
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    x3: number,
    y3: number,
    color?: string,
    lineWidth?: number
}


export class TriangleShape implements IDrawingShape {

    constructor(
        public x1: number,
        public y1: number,
        public x2: number,
        public y2: number,
        public x3: number,
        public y3: number,
        public color: string = 'black',
        public lineWidth: number = 2) {
    }

    draw(ctx: CanvasRenderingContext2D): void {

        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.beginPath();
        ctx.moveTo(this.x1, this.y1);
        ctx.lineTo(this.x2, this.y2);
        ctx.lineTo(this.x3, this.y3);
        ctx.closePath();
        ctx.stroke();
    }

    isHit(x: number, y: number): boolean {
        const tolerance = 6;
        return (
            this.isPointNearLine(x, y, this.x1, this.y1, this.x2, this.y2, tolerance) ||
            this.isPointNearLine(x, y, this.x2, this.y2, this.x3, this.y3, tolerance) ||
            this.isPointNearLine(x, y, this.x3, this.y3, this.x1, this.y1, tolerance)
        );
    }

    private isPointNearLine(px: number, py: number, x1: number, y1: number, x2: number, y2: number, tolerance: number): boolean {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        } else if (param > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return (dx * dx + dy * dy) <= tolerance * tolerance;
    }
}

// File: src/components/Drawing/types.ts
import {Mode} from "../../contexts/ModeContext.tsx";

export type Drawing = {
    mode: Mode;
    args: any; // 转 祝 -type 拽 转专  砖
}

// File: src/components/Toolbar/ModeButton.tsx


import React from 'react';
import { Mode } from '../../contexts/ModeContext';

interface ModeButtonProps {
  mode: Mode;
  currentMode: Mode;
  onClick: (mode: Mode) => void;
  label: string;
}

const ModeButton: React.FC<ModeButtonProps> = ({ mode, currentMode, onClick, label }) => {
  const selected = mode === currentMode;
  return (
    <button
      className={selected ? 'selected' : ''}
      onClick={() => onClick(mode)}
    >
      {label}
    </button>
  );
};

export default ModeButton;

// File: src/components/Toolbar/SettingsToolbar.tsx
import React from 'react';
import '../../styles/SettingsToolbar.scss';
export const SettingsToolbar: React.FC = () => {
    const handleDownload = () => {
        const canvas = document.querySelector('Canvas');
        if (!canvas) return;
        const link = document.createElement('a');
        link.download = 'chart-snapshot.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
    };

    return (
        <div className={'settings-toolbar'}>
            <input type="text" placeholder="Symbol"/>
            <select>
                <option value="1m">1 Min</option>
                <option value="5m">5 Min</option>
                <option value="1h">1 Hour</option>
                <option value="1d">1 Day</option>
            </select>
            <select>
                <option value="50">50 Bars</option>
                <option value="100">100 Bars</option>
                <option value="200">200 Bars</option>
            </select>
            <select>
                <option value="candlestick">Candlestick</option>
                <option value="line">Line</option>
            </select>
            <button onClick={handleDownload}> Snapshot</button>
            <button>锔 Settings</button>
        </div>
    );
};

// File: src/components/Toolbar/Toolbar.tsx
import React from 'react';
import { Mode, useMode } from '../../contexts/ModeContext';
import ModeButton from './ModeButton';
import '../../styles/Toolbar.scss';

export const Toolbar: React.FC = () => {
  const { mode, setMode } = useMode();

  return (
    <div className={'toolbar-container'}>
      <div className={'toolbar'}>
        <ModeButton mode={Mode.drawLine} currentMode={mode} onClick={setMode} label="D Line" />
        <ModeButton mode={Mode.drawRectangle} currentMode={mode} onClick={setMode} label="D Rect" />
        <ModeButton mode={Mode.drawCircle} currentMode={mode} onClick={setMode} label="D Cir" />
        <ModeButton mode={Mode.drawTriangle} currentMode={mode} onClick={setMode} label="D Triangle" />
        <ModeButton mode={Mode.drawAngle} currentMode={mode} onClick={setMode} label="D Angle" />
        <ModeButton mode={Mode.select} currentMode={mode} onClick={setMode} label="Select" />
        <ModeButton mode={Mode.editShape} currentMode={mode} onClick={setMode} label="Edit" />
      </div>
    </div>
  );
};

// File: src/contexts/ModeContext.tsx
import React, {createContext, useContext, useState} from 'react';

export enum Mode {
    none,
    drawLine,
    drawRectangle,
    drawCircle,
    drawTriangle,
    drawAngle,
    select,
    editShape,
    drawPolyline,
    drawArrow,
    drawCustomSymbol,
    drawText
}

interface ModeContextProps {
    mode: Mode;
    setMode: (mode: Mode) => void;
}

const ModeContext = createContext<ModeContextProps | undefined>(undefined);

export const ModeProvider: React.FC<{ children: React.ReactNode }> = ({children}) => {
    const [mode, setModeState] = useState<Mode>(Mode.none);

    const setMode = (newMode: Mode) => {
        setModeState(prev => (prev === newMode ? Mode.none : newMode));
    };

    return (
        <ModeContext.Provider value={{mode, setMode}}>
            {children}
        </ModeContext.Provider>
    );
};

export const useMode = (): ModeContextProps => {
    const context = useContext(ModeContext);
    if (!context) {
        throw new Error('useMode must be used within a ModeProvider');
    }
    return context;
};

// File: src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import {App} from './components/App';
import {ModeProvider} from './contexts/ModeContext';

const root = document.getElementById('root') as HTMLElement;

ReactDOM.createRoot(root).render(
    <React.StrictMode>
        <ModeProvider>
            <App/>
        </ModeProvider>
    </React.StrictMode>
);

// File: src/styles/App.scss
//make the html file to cover the whole screen
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
    overflow: hidden; /* 注  转专转 */
}

#root {
  height: calc(100% - 4px); /* 专  砖 -toolbar */
  width: calc(100% - 4px); /* 专 专 砖 -toolbar */
  margin: 2px;
  padding: 0;
  display: flex;
  flex-direction: column;
  overflow: hidden; /* 注  转专转 */
}

// make the app container to cover the whole screen
.main-app-window {
  display: flex;
  flex-direction: column;
  position: relative;
  height: 100%;
  width: 100%;
  padding: 2px;
  box-sizing: border-box;
  overflow: hidden; /* 注  转专转 */
}

.settings-area {
  display: flex;
  flex-direction: row;
  height: 30px;
  width: 100%;
}

.lower-container {
  height: calc(100% - 40px);
  width: 100%;
  display: flex;
  flex-direction: row;
  overflow: hidden; /* 注  驻拽转 */
}

//   拽转 拽抓 专, 住祝 :
.chart-canvas-container {
  flex-grow: 1;
  width: calc(100% - 40px); /* 专 专 砖 -toolbar */
  height: 100%;
  position: relative;
}

.toolbar-container {
  width: 40px; /* 专 住专  */
  height: 100%;
  flex-shrink: 0; /* 注 抓 */
}

// File: src/styles/Canvas/Axes.scss


// File: src/styles/Canvas/Grid.scss


// File: src/styles/ChartCanves.scss
.chart-canvas-container {
  flex-grow: 1;
  width: calc(100% - 40px); /* 专 专 砖 -toolbar */
  height: 100%;
  position: relative;
  display: block;
  max-height: 100%;
}

// File: src/styles/Drawing.scss


// File: src/styles/Overlays.scss


// File: src/styles/SettingsToolbar.scss

.settings-toolbar {
  background: #ddd;
  display: flex;
  height: 100%;
  width: 100%;
  justify-content: start;
  align-content: center;
  align-items: center;

  input, select, button {
    height: 100%;
    border-radius: 3px;
    border-width: 1px;
    width: fit-content;
    font-size: 11px;
    padding: 0 5px;
  }

  input {
    height: calc(100% - 2px);
    width: 100px;
  }

}

// File: src/styles/Toolbar.scss
@use '../styles/variables' as v;

.toolbar-container {
  display: flex;
  flex-grow: 0;
  flex-shrink: 0;
  width: v.$toolbar-width;
  background-color: #ddd;
  height: 100%;
}

.toolbar {
  width: v.$toolbar-width;
  height: 100%;
  display: grid;
  grid-column: 1;
  grid-auto-flow: row;
  grid-template-rows: auto;
  grid-template-columns: auto;
  align-content: start;

  button {
    display: flex;
    min-height: v.$toolbar-width;
    width: 100%;
    flex-grow: 1;
    padding: 0;
    overflow: hidden;
    text-align: center;
    font-size: 10px;

    &.selected {
      background-color: #333;
      color: #fff;
      border-left: 3px solid #007bff;
    }
  }
}

// File: src/styles/_variables.scss

$toolbar-width: 40px;

// File: src/types/Candle.ts
// 驻住 Candle 注 砖转 t, o, c, l, h
export interface Candle {
    t: number; // timestamp
    o: number; // open
    c: number; // close
    l: number; // low
    h: number; // high
}
export interface CandleWithIndex extends Candle {
    index: number; // index in the original array
}

// File: src/types/chartStyleOptions.d.ts
// chartStyleOptions.ts

// Candles style
import {AxesPosition} from "./types.ts";

export interface CandleStyleOptions {
    upColor?: string;
    downColor?: string;
    borderColor?: string;
    borderWidth?: number;
    bodyWidthFactor?: number;
    spacingFactor?: number;
}

// Grid style
export interface GridStyleOptions {
    gridSpacing?: number;
    lineColor?: string;
    lineWidth?: number;
    lineDash?: number[];
}

// Axes style
export interface AxesStyleOptions {
    axisPosition?: AxesPosition;
    textColor?: string;
    font?: string;
    lineColor?: string;
    lineWidth?: number;
    numberLocale?: string;
    dateLocale?: string;
    numberFractionDigits?: number; // Number of decimal places to format axis values
}
export interface LineOverlayOptions{
    color?: string;
    lineWidth?: number;
    dashed?: boolean;
}
// Main Chart style options
export interface ChartStyleOptions {
    candles?: CandleStyleOptions;
    grid?: GridStyleOptions;
    axes?: AxesStyleOptions;
    lineOverlay?:LineOverlayOptions;
    backgroundColor?:string;
    // 驻砖专 住祝 驻 注 (砖 lineOverlay ')
}

// File: src/types/types.ts
import {ChartStyleOptions} from "./chartStyleOptions";

// Enum for Axis position
export enum AxesPosition {
    left = 'left',
    right = 'right',
}

// Base chart options
interface BaseChartOptions {
    theme?: 'light' | 'dark' | 'grey' | string;
    showOverlayLine?: boolean;
    style?: Partial<ChartStyleOptions>;
}

// Line chart data point
export interface LineData {
    time: number;
    value: number;
}

// Candlestick chart data point (full)
export interface CandleData {
    time: number;
    open: number;
    high: number;
    low: number;
    close: number;
}

// Candlestick chart data point (compact)
export interface CandleDataCompact {
    t: number;
    o: number;
    h: number;
    l: number;
    c: number;
}

// Line chart options
export interface LineChartOptions extends BaseChartOptions {
    type: 'line';
    data: LineData[];
}

// Candlestick chart options
export interface CandleChartOptions extends BaseChartOptions {
    type: 'candlestick';
    data: (CandleData | CandleDataCompact)[];
}

// Unified ChartOptions type
export type ChartOptions = LineChartOptions | CandleChartOptions;

// File: src/vite-env.d.ts
/// <reference types="vite/client" />


